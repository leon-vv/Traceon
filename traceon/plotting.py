"""The `traceon.plotting` module uses the `vedo` plotting library to provide some convenience functions
to show the line and triangle meshes generated by Traceon."""

from math import sqrt
from scipy.interpolate import *
import numpy as np
import vedo

from . import backend
from .geometry import Symmetry

def _create_point_to_physical_dict(mesh):
    d = {}
    
    for physical, elements in [(mesh.physical_to_lines, mesh.lines), (mesh.physical_to_triangles, mesh.triangles)]:
        for k, v in physical.items():
            for element_index in v:
                for p in elements[element_index]:
                    d[p] = k
     
    return d


def plot_mesh(mesh, show_normals=False, show_legend=True, **colors):
    """Plot mesh using the Vedo library. Optionally showing normal vectors.

    Parameters
    ---------------------
    show_normals: bool
        Whether to show the normal vectors at every element
    show_legend: bool
        Whether to show the legend
    colors: dict of (string, string)
        Use keyword arguments to specify colors, for example `plot_mesh(mesh, lens='blue', ground='green')`
    """
    plotter = vedo.Plotter()
    points_to_physical = _create_point_to_physical_dict(mesh)
    legend_entries = []
    
    if len(mesh.triangles):
        meshes = _plot_triangle_mesh(mesh, plotter, points_to_physical, show_normals=show_normals, **colors)
        legend_entries.extend(meshes)
    
    if len(mesh.lines) and not mesh.is_3d():
        lines = _plot_line_mesh(mesh, plotter, points_to_physical, show_normals=show_normals, **colors)
        legend_entries.extend(lines)

    if show_legend:
        lb = vedo.LegendBox(legend_entries)
        plotter += lb
    
    if mesh.points.shape[1] == 3 and np.any(mesh.points[:, 2] != 0.):
        plotter.show(viewup='z', axes={'xtitle': 'x (mm)', 'ytitle': 'y (mm)', 'ztitle': 'z (mm)'})
    else:
        plotter.show(axes={'xtitle': 'x (mm)', 'ytitle': 'y (mm)'})

def _plot_triangle_mesh(mesh, plotter, points_to_physical, show_normals=False, **phys_colors):
    triangles = mesh.triangles[:, :3]
    normals = np.array([backend.normal_3d(*mesh.points[t]) for t in triangles])
    
    colors = np.full(len(triangles), '#CCCCCC')
    dict_ = points_to_physical
    
    for i, (A, B, C) in enumerate(triangles):
        if A in dict_ and B in dict_ and C in dict_:
            phys1, phys2, phys3 = dict_[A], dict_[B], dict_[C]
            if phys1 == phys2 and phys2 == phys3 and phys1 in phys_colors:
                colors[i] = phys_colors[phys1]
     
    meshes = []
    
    for c in set(colors):
        mask = colors == c
        vm = vedo.Mesh([mesh.points, triangles[mask]], c)
        vm.linecolor('black').linewidth(2)
        
        key = [k for k, col in phys_colors.items() if c==col]
        if len(key):
            vm.legend(key[0])
        
        plotter += vm
        meshes.append(vm)
    
    if show_normals:
        start_to_end = np.zeros( (len(triangles), 6) )
        for i, t in enumerate(triangles):
            v1, v2, v3 = mesh.points[t]
            middle = (v1 + v2 + v3)/3
            area = 1/2*np.linalg.norm(np.cross(v2-v1, v3-v1))
            side_length = sqrt( (4*area) / sqrt(3) ) # Equilateral triangle, side length with equal area
            normal = 0.75*side_length*normals[i]
            start_to_end[i] = [*middle, *(middle+normal)]
         
        arrows = vedo.shapes.Arrows(start_to_end[:, :3], start_to_end[:, 3:], res=20, c='black')
        plotter.add(arrows)
     
    return meshes


def _plot_line_mesh(mesh, plotter, points_to_physical, show_normals=False, **phys_colors):
    start = []
    end = []
    colors_ = []
    normals = []
    dict_ = points_to_physical
    lines = mesh.lines[:, :2]
     
    for i, (A, B) in enumerate(lines):
            color = '#CCCCC'
            
            if A in dict_ and B in dict_:
                phys1, phys2 = dict_[A], dict_[B]
                if phys1 == phys2 and phys1 in phys_colors:
                    color = phys_colors[phys1]
            
            p1, p2 = mesh.points[A], mesh.points[B]
            start.append(p1)
            end.append(p2)
            colors_.append(color)
            normals.append(backend.normal_2d(p1[:2], p2[:2]))
     
    start, end = np.array(start), np.array(end)
    colors_ = np.array(colors_)
    vedo_lines = []
     
    for c in set(colors_):
        mask = colors_ == c
        l = vedo.Lines(start[mask], end[mask], lw=3, c=c)
        
        key = [k for k, col in phys_colors.items() if c==col]
        if len(key):
            l.legend(key[0])
         
        plotter += l
        vedo_lines.append(l)
     
    if show_normals:
        arrows_to_plot = np.zeros( (len(normals), 4) )
        
        for i, (v1, v2) in enumerate(zip(start, end)):
            v1, v2 = v1[:2], v2[:2]
            middle = (v1 + v2)/2
            length = np.linalg.norm(v2-v1)
            normal = 3*length*normals[i]
            arrows_to_plot[i] = [*middle, *(middle+normal)]
        
        arrows = vedo.shapes.Arrows(arrows_to_plot[:, :2], arrows_to_plot[:, 2:], c='black')
        plotter.add(arrows)

    return vedo_lines
    

