<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>traceon.tracing API documentation</title>
<meta name="description" content="The tracing module allows to trace electrons within any field type returned by the `traceon.solver` module. The tracing algorithm
used is RK45 with â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>traceon.tracing</code></h1>
</header>
<section id="section-intro">
<p>The tracing module allows to trace electrons within any field type returned by the <code><a title="traceon.solver" href="solver.html">traceon.solver</a></code> module. The tracing algorithm
used is RK45 with adaptive step size control [1]. The tracing code is implemented in C (see <code>traceon.backend</code>) and has therefore
excellent performance. The module also provides various helper functions to define appropriate initial velocity vectors and to
compute intersections of the computed traces with various planes.</p>
<h3 id="references">References</h3>
<p>[1] Erwin Fehlberg. Low-Order Classical Runge-Kutta Formulas With Stepsize Control and their Application to Some Heat
Transfer Problems. 1969. National Aeronautics and Space Administration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The tracing module allows to trace electrons within any field type returned by the `traceon.solver` module. The tracing algorithm
used is RK45 with adaptive step size control [1]. The tracing code is implemented in C (see `traceon.backend`) and has therefore
excellent performance. The module also provides various helper functions to define appropriate initial velocity vectors and to
compute intersections of the computed traces with various planes.

### References
[1] Erwin Fehlberg. Low-Order Classical Runge-Kutta Formulas With Stepsize Control and their Application to Some Heat
Transfer Problems. 1969. National Aeronautics and Space Administration.&#34;&#34;&#34;


from math import sqrt, cos, sin, atan2
import time
from enum import Enum

import matplotlib.pyplot as plt
import numpy as np
import scipy
from scipy.integrate import *

from . import solver as S
from . import backend

EM = -0.1758820022723908 # e/m units ns and mm


def velocity_vec(eV, direction):
    &#34;&#34;&#34;Compute an initial velocity vector in the correct units and direction.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    direction: (2,) or (3,) numpy array
        vector giving the correct direction of the initial velocity vector. Does not
        have to be a unit vector as it is always normalized.

    Returns
    -------
    Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).
    The shape of the resulting vector is the same as the shape of `direction`.
    &#34;&#34;&#34;
    assert eV &gt; 0.0
    
    if eV &gt; 40000:
        print(f&#39;WARNING: velocity vector with large energy ({eV} eV) requested. Note that relativistic tracing is not yet implemented.&#39;)
     
    # From electronvolt to mm/ns
    V = 0.5930969604919433*sqrt(eV)
    return V* np.array(direction)/np.linalg.norm(direction)

def velocity_vec_spherical(eV, theta, phi):
    &#34;&#34;&#34;Compute initial velocity vector given energy and direction computed from spherical coordinates.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    theta: float
        angle with z-axis (same definition as theta in a spherical coordinate system)
    phi: float
        angle with the x-axis (same definition as phi in a spherical coordinate system)

    Returns
    ------
    Initial velocity vector of shape (3,) with magnitude corresponding to the supplied energy and correct units (mm/ns).
    &#34;&#34;&#34;
    return velocity_vec(eV, [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)])

def velocity_vec_xz_plane(eV, angle, downward=True, three_dimensional=False):
    &#34;&#34;&#34;Compute initial velocity vector in the xz plane with the given energy and angle with z-axis.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    angle: float
        angle with z-axis
    downward: bool
        whether the velocity vector should point upward or downwards
    three_dimensional: bool
        whether the resulting velocity vector has shape (2,) or shape (3,)
     
    Returns
    ------
    Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).
    &#34;&#34;&#34;
    sign = -1 if downward else 1
    direction = [sin(angle), sign*cos(angle)] if not three_dimensional else [sin(angle), 0.0, sign*cos(angle)]
    return velocity_vec(eV, direction)
    
def _z_to_bounds(z1, z2):
    if z1 &lt; 0 and z2 &lt; 0:
        return (min(z1, z2)-1, 1.0)
    elif z1 &gt; 0 and z2 &gt; 0:
        return (-1.0, max(z1, z2)+1)
    else:
        return (min(z1, z2)-1, max(z1, z2)+1)

class Tracer:
    &#34;&#34;&#34;General electron tracer class. Can trace electrons given any field class from `traceon.solver`.

    Parameters
    ----------
    field: traceon.solver.Field (or any class inheriting Field)
        The field used to compute the force felt by the electron.
    bounds: (2, 3) or (3, 3) np.ndarray of float64
        Once the electron reaches one of the boundaries the tracing stops. The bounds are either of the form
        ( (rmin, rmax), (zmin, zmax) ) for radial symmetric geometries or 
        ( (xmin, xmax), (ymin, ymax), (zmin, zmax) ) for 3D geometries.
    atol: float
        Absolute tolerance determining the accuracy of the trace.
    &#34;&#34;&#34;
    
    def __init__(self, field, bounds, atol=1e-10):
          
        self.field = field
        assert isinstance(field, S.FieldRadialBEM) or isinstance(field, S.FieldRadialAxial) or \
               isinstance(field, S.Field3D_BEM)    or isinstance(field, S.Field3DAxial)
         
        self.bounds = bounds
        self.atol = atol
    
    def __str__(self):
        field_name = self.field.__class__.__name__
        bounds_str = &#39; &#39;.join([f&#39;({bmin:.2f}, {bmax:.2f})&#39; for bmin, bmax in self.bounds])
        return f&#39;&lt;Traceon Tracer of {field_name},\n\t&#39; \
            + &#39;Bounds: &#39; + bounds_str + &#39; mm &gt;&#39;
        
    def __call__(self, position, velocity):
        &#34;&#34;&#34;Trace an electron.

        Parameters
        ----------
        position: (2,) or (3,) np.ndarray of float64
            Initial position of electron.
        velocity: (2,) or (3,) np.ndarray of float64
            Initial velocity (in units of mm/ns). Use one of the utility functions documented
            above to create the initial velocity vector.
        
        Returns
        -------
        `(times, positions)` which is a tuple of two numpy arrays. `times` is one dimensional and contains the times
        (in ns) at which the positions have been computed. The `positions` array is two dimensional, `positions[i]` correspond
        to time step `times[i]`. One element of the positions array has either shape (4,) in radial symmetry or (6,) in three
        dimensional geometries. The last two or three (depending on symmetry) elements in `positions[i]` contain the corresponding
        velocity vector.
        &#34;&#34;&#34;

        if isinstance(self.field, S.FieldRadialBEM):
            return backend.trace_particle_radial(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
        elif isinstance(self.field, S.FieldRadialAxial):
            return backend.trace_particle_radial_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)
        elif isinstance(self.field, S.Field3D_BEM):
            return backend.trace_particle_3d(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
        elif isinstance(self.field, S.Field3DAxial):
            return backend.trace_particle_3d_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)
 

def plane_intersection(positions, p0, normal):
    &#34;&#34;&#34;Compute the intersection of a trajectory with a general plane in 3D. The plane is specified
    by a point (p0) in the plane and a normal vector (normal) to the plane. The intersection
    point is calculated using a linear interpolation.
    
    Parameters
    ----------
    positions: (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    
    p0: (3,) np.ndarray of float64
        A point that lies in the plane.

    normal: (3,) np.ndarray of float64
        A vector that is normal to the plane. A point p lies in the plane iff `dot(normal, p - p0) = 0` where
        dot is the dot product.
    
    Returns
    --------
    np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;

    return backend.plane_intersection(positions, p0, normal)

def line_intersection(positions, p0, tangent):
    &#34;&#34;&#34;Compute the intersection of a trajectory with a line in 2D. The line is specified
    by a point (p0) on the line and a vector tangential (tangent) to the line. The intersection
    point is calculated using a linear interpolation.
    
    Parameters
    ----------
    positions: (N, 4) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    
    p0: (2,) np.ndarray of float64
        A point that lies on the line.
    
    tangent: (2,) np.ndarray of float64
        A vector that is tangential to the line. A point p lies on the line if there exists a number k
        such that `p0 + k*tangent = p`.
    
    Returns
    --------
    np.ndarray of shape (4,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;

    return backend.line_intersection(positions, p0, tangent)

def xy_plane_intersection(positions, z):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an xy-plane.

    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    z: float
        z-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
    
    if positions.shape[1] == 4:
        return line_intersection(positions, np.array([0., z]), np.array([1.0, 0.0]))
    else:
        return plane_intersection(positions, np.array([0.,0.,z]), np.array([0., 0., 1.0]))

def xz_plane_intersection(positions, y):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an xz-plane. Note that this function
    does not make sense in 2D (where we consider (r,z) as (x,z) and therefore the y-axis is missing).

    Parameters
    ----------
    positions: (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    y: float
        y-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    return plane_intersection(positions, np.array([0.,y,0.]), np.array([0., 1.0, 0.]))

def yz_plane_intersection(positions, x):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an yz-plane.

    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    x: float
        x-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
     
    if positions.shape[1] == 4:
        return line_intersection(positions, np.array([x, 0.]), np.array([0.0, 1.0]))
    else:
        return plane_intersection(positions, np.array([x,0.,0.]), np.array([1.0, 0., 0.]))


def axis_intersection(positions):
    &#34;&#34;&#34;Calculate the intersection with the optical axis using a linear interpolation. Notice that
    this only makes sense in 2D as in 3D the particle will never pass exactly through the optical axis.
    However, this function is implemented as `yz_plane_intersection(positions, 0.0)` and will therefore
    give meaningful results in 3D if you expect the particle trajectory to be in the xz plane. This function
    only returns the z-coordinate. Use `yz_plane_intersection` directly if you want to retrieve the velocity 
    components.
    
    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        positions of an electron as returned by `Tracer`.
    
    Returns
    ----------
    float z-coordinate of intersection point
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
    
    z_index = 1 if positions.shape[1] == 4 else 2
    return yz_plane_intersection(positions, 0.)[z_index]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="traceon.tracing.axis_intersection"><code class="name flex">
<span>def <span class="ident">axis_intersection</span></span>(<span>positions)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the intersection with the optical axis using a linear interpolation. Notice that
this only makes sense in 2D as in 3D the particle will never pass exactly through the optical axis.
However, this function is implemented as <code><a title="traceon.tracing.yz_plane_intersection" href="#traceon.tracing.yz_plane_intersection">yz_plane_intersection()</a>(positions, 0.0)</code> and will therefore
give meaningful results in 3D if you expect the particle trajectory to be in the xz plane. This function
only returns the z-coordinate. Use <code><a title="traceon.tracing.yz_plane_intersection" href="#traceon.tracing.yz_plane_intersection">yz_plane_intersection()</a></code> directly if you want to retrieve the velocity
components.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 4)</code> or <code>(N, 6) np.ndarray</code> of <code>float64</code></dt>
<dd>positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float z-coordinate</code> of <code>intersection point</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axis_intersection(positions):
    &#34;&#34;&#34;Calculate the intersection with the optical axis using a linear interpolation. Notice that
    this only makes sense in 2D as in 3D the particle will never pass exactly through the optical axis.
    However, this function is implemented as `yz_plane_intersection(positions, 0.0)` and will therefore
    give meaningful results in 3D if you expect the particle trajectory to be in the xz plane. This function
    only returns the z-coordinate. Use `yz_plane_intersection` directly if you want to retrieve the velocity 
    components.
    
    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        positions of an electron as returned by `Tracer`.
    
    Returns
    ----------
    float z-coordinate of intersection point
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
    
    z_index = 1 if positions.shape[1] == 4 else 2
    return yz_plane_intersection(positions, 0.)[z_index]</code></pre>
</details>
</dd>
<dt id="traceon.tracing.line_intersection"><code class="name flex">
<span>def <span class="ident">line_intersection</span></span>(<span>positions, p0, tangent)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection of a trajectory with a line in 2D. The line is specified
by a point (p0) on the line and a vector tangential (tangent) to the line. The intersection
point is calculated using a linear interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 4) np.ndarray</code> of <code>float64</code></dt>
<dd>Positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>p0</code></strong> :&ensp;<code>(2,) np.ndarray</code> of <code>float64</code></dt>
<dd>A point that lies on the line.</dd>
<dt><strong><code>tangent</code></strong> :&ensp;<code>(2,) np.ndarray</code> of <code>float64</code></dt>
<dd>A vector that is tangential to the line. A point p lies on the line if there exists a number k
such that <code>p0 + k*tangent = p</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray of shape (4,) containing the position and velocity of the electron at the intersection point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line_intersection(positions, p0, tangent):
    &#34;&#34;&#34;Compute the intersection of a trajectory with a line in 2D. The line is specified
    by a point (p0) on the line and a vector tangential (tangent) to the line. The intersection
    point is calculated using a linear interpolation.
    
    Parameters
    ----------
    positions: (N, 4) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    
    p0: (2,) np.ndarray of float64
        A point that lies on the line.
    
    tangent: (2,) np.ndarray of float64
        A vector that is tangential to the line. A point p lies on the line if there exists a number k
        such that `p0 + k*tangent = p`.
    
    Returns
    --------
    np.ndarray of shape (4,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;

    return backend.line_intersection(positions, p0, tangent)</code></pre>
</details>
</dd>
<dt id="traceon.tracing.plane_intersection"><code class="name flex">
<span>def <span class="ident">plane_intersection</span></span>(<span>positions, p0, normal)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection of a trajectory with a general plane in 3D. The plane is specified
by a point (p0) in the plane and a normal vector (normal) to the plane. The intersection
point is calculated using a linear interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 6) np.ndarray</code> of <code>float64</code></dt>
<dd>Positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>p0</code></strong> :&ensp;<code>(3,) np.ndarray</code> of <code>float64</code></dt>
<dd>A point that lies in the plane.</dd>
<dt><strong><code>normal</code></strong> :&ensp;<code>(3,) np.ndarray</code> of <code>float64</code></dt>
<dd>A vector that is normal to the plane. A point p lies in the plane iff <code>dot(normal, p - p0) = 0</code> where
dot is the dot product.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane_intersection(positions, p0, normal):
    &#34;&#34;&#34;Compute the intersection of a trajectory with a general plane in 3D. The plane is specified
    by a point (p0) in the plane and a normal vector (normal) to the plane. The intersection
    point is calculated using a linear interpolation.
    
    Parameters
    ----------
    positions: (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    
    p0: (3,) np.ndarray of float64
        A point that lies in the plane.

    normal: (3,) np.ndarray of float64
        A vector that is normal to the plane. A point p lies in the plane iff `dot(normal, p - p0) = 0` where
        dot is the dot product.
    
    Returns
    --------
    np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;

    return backend.plane_intersection(positions, p0, normal)</code></pre>
</details>
</dd>
<dt id="traceon.tracing.velocity_vec"><code class="name flex">
<span>def <span class="ident">velocity_vec</span></span>(<span>eV, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an initial velocity vector in the correct units and direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>initial energy in units of eV</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>(2,)</code> or <code>(3,) numpy array</code></dt>
<dd>vector giving the correct direction of the initial velocity vector. Does not
have to be a unit vector as it is always normalized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).
The shape of the resulting vector is the same as the shape of <code>direction</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def velocity_vec(eV, direction):
    &#34;&#34;&#34;Compute an initial velocity vector in the correct units and direction.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    direction: (2,) or (3,) numpy array
        vector giving the correct direction of the initial velocity vector. Does not
        have to be a unit vector as it is always normalized.

    Returns
    -------
    Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).
    The shape of the resulting vector is the same as the shape of `direction`.
    &#34;&#34;&#34;
    assert eV &gt; 0.0
    
    if eV &gt; 40000:
        print(f&#39;WARNING: velocity vector with large energy ({eV} eV) requested. Note that relativistic tracing is not yet implemented.&#39;)
     
    # From electronvolt to mm/ns
    V = 0.5930969604919433*sqrt(eV)
    return V* np.array(direction)/np.linalg.norm(direction)</code></pre>
</details>
</dd>
<dt id="traceon.tracing.velocity_vec_spherical"><code class="name flex">
<span>def <span class="ident">velocity_vec_spherical</span></span>(<span>eV, theta, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute initial velocity vector given energy and direction computed from spherical coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>initial energy in units of eV</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>angle with z-axis (same definition as theta in a spherical coordinate system)</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>angle with the x-axis (same definition as phi in a spherical coordinate system)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Initial velocity vector of shape (3,) with magnitude corresponding to the supplied energy and correct units (mm/ns).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def velocity_vec_spherical(eV, theta, phi):
    &#34;&#34;&#34;Compute initial velocity vector given energy and direction computed from spherical coordinates.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    theta: float
        angle with z-axis (same definition as theta in a spherical coordinate system)
    phi: float
        angle with the x-axis (same definition as phi in a spherical coordinate system)

    Returns
    ------
    Initial velocity vector of shape (3,) with magnitude corresponding to the supplied energy and correct units (mm/ns).
    &#34;&#34;&#34;
    return velocity_vec(eV, [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)])</code></pre>
</details>
</dd>
<dt id="traceon.tracing.velocity_vec_xz_plane"><code class="name flex">
<span>def <span class="ident">velocity_vec_xz_plane</span></span>(<span>eV, angle, downward=True, three_dimensional=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute initial velocity vector in the xz plane with the given energy and angle with z-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>initial energy in units of eV</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>angle with z-axis</dd>
<dt><strong><code>downward</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the velocity vector should point upward or downwards</dd>
<dt><strong><code>three_dimensional</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the resulting velocity vector has shape (2,) or shape (3,)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def velocity_vec_xz_plane(eV, angle, downward=True, three_dimensional=False):
    &#34;&#34;&#34;Compute initial velocity vector in the xz plane with the given energy and angle with z-axis.
    
    Parameters
    ----------
    eV: float
        initial energy in units of eV
    angle: float
        angle with z-axis
    downward: bool
        whether the velocity vector should point upward or downwards
    three_dimensional: bool
        whether the resulting velocity vector has shape (2,) or shape (3,)
     
    Returns
    ------
    Initial velocity vector with magnitude corresponding to the supplied energy and correct units (mm/ns).
    &#34;&#34;&#34;
    sign = -1 if downward else 1
    direction = [sin(angle), sign*cos(angle)] if not three_dimensional else [sin(angle), 0.0, sign*cos(angle)]
    return velocity_vec(eV, direction)</code></pre>
</details>
</dd>
<dt id="traceon.tracing.xy_plane_intersection"><code class="name flex">
<span>def <span class="ident">xy_plane_intersection</span></span>(<span>positions, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection of a trajectory with an xy-plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 4)</code> or <code>(N, 6) np.ndarray</code> of <code>float64</code></dt>
<dd>Positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate of the plane with which to compute the intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xy_plane_intersection(positions, z):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an xy-plane.

    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    z: float
        z-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
    
    if positions.shape[1] == 4:
        return line_intersection(positions, np.array([0., z]), np.array([1.0, 0.0]))
    else:
        return plane_intersection(positions, np.array([0.,0.,z]), np.array([0., 0., 1.0]))</code></pre>
</details>
</dd>
<dt id="traceon.tracing.xz_plane_intersection"><code class="name flex">
<span>def <span class="ident">xz_plane_intersection</span></span>(<span>positions, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection of a trajectory with an xz-plane. Note that this function
does not make sense in 2D (where we consider (r,z) as (x,z) and therefore the y-axis is missing).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 6) np.ndarray</code> of <code>float64</code></dt>
<dd>Positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y-coordinate of the plane with which to compute the intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xz_plane_intersection(positions, y):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an xz-plane. Note that this function
    does not make sense in 2D (where we consider (r,z) as (x,z) and therefore the y-axis is missing).

    Parameters
    ----------
    positions: (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    y: float
        y-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    return plane_intersection(positions, np.array([0.,y,0.]), np.array([0., 1.0, 0.]))</code></pre>
</details>
</dd>
<dt id="traceon.tracing.yz_plane_intersection"><code class="name flex">
<span>def <span class="ident">yz_plane_intersection</span></span>(<span>positions, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection of a trajectory with an yz-plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>(N, 4)</code> or <code>(N, 6) np.ndarray</code> of <code>float64</code></dt>
<dd>Positions of an electron as returned by <code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code>.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordinate of the plane with which to compute the intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def yz_plane_intersection(positions, x):
    &#34;&#34;&#34;Compute the intersection of a trajectory with an yz-plane.

    Parameters
    ----------
    positions: (N, 4) or (N, 6) np.ndarray of float64
        Positions of an electron as returned by `Tracer`.
    x: float
        x-coordinate of the plane with which to compute the intersection
    
    Returns
    --------
    np.ndarray of shape (4,) or (6,) containing the position and velocity of the electron at the intersection point.
    &#34;&#34;&#34;
    assert positions.shape == (len(positions), 4) or positions.shape == (len(positions), 6)
     
    if positions.shape[1] == 4:
        return line_intersection(positions, np.array([x, 0.]), np.array([0.0, 1.0]))
    else:
        return plane_intersection(positions, np.array([x,0.,0.]), np.array([1.0, 0., 0.]))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="traceon.tracing.Tracer"><code class="flex name class">
<span>class <span class="ident">Tracer</span></span>
<span>(</span><span>field, bounds, atol=1e-10)</span>
</code></dt>
<dd>
<div class="desc"><p>General electron tracer class. Can trace electrons given any field class from <code><a title="traceon.solver" href="solver.html">traceon.solver</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>field</code></strong> :&ensp;<code><a title="traceon.solver.Field" href="solver.html#traceon.solver.Field">Field</a> (or any class inheriting Field)</code></dt>
<dd>The field used to compute the force felt by the electron.</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>(2, 3)</code> or <code>(3, 3) np.ndarray</code> of <code>float64</code></dt>
<dd>Once the electron reaches one of the boundaries the tracing stops. The bounds are either of the form
( (rmin, rmax), (zmin, zmax) ) for radial symmetric geometries or
( (xmin, xmax), (ymin, ymax), (zmin, zmax) ) for 3D geometries.</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code></dt>
<dd>Absolute tolerance determining the accuracy of the trace.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tracer:
    &#34;&#34;&#34;General electron tracer class. Can trace electrons given any field class from `traceon.solver`.

    Parameters
    ----------
    field: traceon.solver.Field (or any class inheriting Field)
        The field used to compute the force felt by the electron.
    bounds: (2, 3) or (3, 3) np.ndarray of float64
        Once the electron reaches one of the boundaries the tracing stops. The bounds are either of the form
        ( (rmin, rmax), (zmin, zmax) ) for radial symmetric geometries or 
        ( (xmin, xmax), (ymin, ymax), (zmin, zmax) ) for 3D geometries.
    atol: float
        Absolute tolerance determining the accuracy of the trace.
    &#34;&#34;&#34;
    
    def __init__(self, field, bounds, atol=1e-10):
          
        self.field = field
        assert isinstance(field, S.FieldRadialBEM) or isinstance(field, S.FieldRadialAxial) or \
               isinstance(field, S.Field3D_BEM)    or isinstance(field, S.Field3DAxial)
         
        self.bounds = bounds
        self.atol = atol
    
    def __str__(self):
        field_name = self.field.__class__.__name__
        bounds_str = &#39; &#39;.join([f&#39;({bmin:.2f}, {bmax:.2f})&#39; for bmin, bmax in self.bounds])
        return f&#39;&lt;Traceon Tracer of {field_name},\n\t&#39; \
            + &#39;Bounds: &#39; + bounds_str + &#39; mm &gt;&#39;
        
    def __call__(self, position, velocity):
        &#34;&#34;&#34;Trace an electron.

        Parameters
        ----------
        position: (2,) or (3,) np.ndarray of float64
            Initial position of electron.
        velocity: (2,) or (3,) np.ndarray of float64
            Initial velocity (in units of mm/ns). Use one of the utility functions documented
            above to create the initial velocity vector.
        
        Returns
        -------
        `(times, positions)` which is a tuple of two numpy arrays. `times` is one dimensional and contains the times
        (in ns) at which the positions have been computed. The `positions` array is two dimensional, `positions[i]` correspond
        to time step `times[i]`. One element of the positions array has either shape (4,) in radial symmetry or (6,) in three
        dimensional geometries. The last two or three (depending on symmetry) elements in `positions[i]` contain the corresponding
        velocity vector.
        &#34;&#34;&#34;

        if isinstance(self.field, S.FieldRadialBEM):
            return backend.trace_particle_radial(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
        elif isinstance(self.field, S.FieldRadialAxial):
            return backend.trace_particle_radial_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)
        elif isinstance(self.field, S.Field3D_BEM):
            return backend.trace_particle_3d(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
        elif isinstance(self.field, S.Field3DAxial):
            return backend.trace_particle_3d_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="traceon.tracing.Tracer.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, position, velocity)</span>
</code></dt>
<dd>
<div class="desc"><p>Trace an electron.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>(2,)</code> or <code>(3,) np.ndarray</code> of <code>float64</code></dt>
<dd>Initial position of electron.</dd>
<dt><strong><code>velocity</code></strong> :&ensp;<code>(2,)</code> or <code>(3,) np.ndarray</code> of <code>float64</code></dt>
<dd>Initial velocity (in units of mm/ns). Use one of the utility functions documented
above to create the initial velocity vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>(times, positions)</code> which is a tuple of two numpy arrays. <code>times</code> is one dimensional and contains the times
(in ns) at which the positions have been computed. The <code>positions</code> array is two dimensional, <code>positions[i]</code> correspond
to time step <code>times[i]</code>. One element of the positions array has either shape (4,) in radial symmetry or (6,) in three
dimensional geometries. The last two or three (depending on symmetry) elements in <code>positions[i]</code> contain the corresponding
velocity vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, position, velocity):
    &#34;&#34;&#34;Trace an electron.

    Parameters
    ----------
    position: (2,) or (3,) np.ndarray of float64
        Initial position of electron.
    velocity: (2,) or (3,) np.ndarray of float64
        Initial velocity (in units of mm/ns). Use one of the utility functions documented
        above to create the initial velocity vector.
    
    Returns
    -------
    `(times, positions)` which is a tuple of two numpy arrays. `times` is one dimensional and contains the times
    (in ns) at which the positions have been computed. The `positions` array is two dimensional, `positions[i]` correspond
    to time step `times[i]`. One element of the positions array has either shape (4,) in radial symmetry or (6,) in three
    dimensional geometries. The last two or three (depending on symmetry) elements in `positions[i]` contain the corresponding
    velocity vector.
    &#34;&#34;&#34;

    if isinstance(self.field, S.FieldRadialBEM):
        return backend.trace_particle_radial(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
    elif isinstance(self.field, S.FieldRadialAxial):
        return backend.trace_particle_radial_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)
    elif isinstance(self.field, S.Field3D_BEM):
        return backend.trace_particle_3d(position, velocity, self.bounds, self.atol, self.field.charges, self.field.jac_buffer, self.field.pos_buffer, self.field.field_bounds)
    elif isinstance(self.field, S.Field3DAxial):
        return backend.trace_particle_3d_derivs(position, velocity, self.bounds, self.atol, self.field.z, self.field.coeffs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#references">References</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="traceon" href="index.html">traceon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="traceon.tracing.axis_intersection" href="#traceon.tracing.axis_intersection">axis_intersection</a></code></li>
<li><code><a title="traceon.tracing.line_intersection" href="#traceon.tracing.line_intersection">line_intersection</a></code></li>
<li><code><a title="traceon.tracing.plane_intersection" href="#traceon.tracing.plane_intersection">plane_intersection</a></code></li>
<li><code><a title="traceon.tracing.velocity_vec" href="#traceon.tracing.velocity_vec">velocity_vec</a></code></li>
<li><code><a title="traceon.tracing.velocity_vec_spherical" href="#traceon.tracing.velocity_vec_spherical">velocity_vec_spherical</a></code></li>
<li><code><a title="traceon.tracing.velocity_vec_xz_plane" href="#traceon.tracing.velocity_vec_xz_plane">velocity_vec_xz_plane</a></code></li>
<li><code><a title="traceon.tracing.xy_plane_intersection" href="#traceon.tracing.xy_plane_intersection">xy_plane_intersection</a></code></li>
<li><code><a title="traceon.tracing.xz_plane_intersection" href="#traceon.tracing.xz_plane_intersection">xz_plane_intersection</a></code></li>
<li><code><a title="traceon.tracing.yz_plane_intersection" href="#traceon.tracing.yz_plane_intersection">yz_plane_intersection</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="traceon.tracing.Tracer" href="#traceon.tracing.Tracer">Tracer</a></code></h4>
<ul class="">
<li><code><a title="traceon.tracing.Tracer.__call__" href="#traceon.tracing.Tracer.__call__">__call__</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>