<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>traceon.excitation API documentation</title>
<meta name="description" content="The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>traceon.excitation</code></h1>
</header>
<section id="section-intro">
<p>The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the <code><a title="traceon.geometry" href="geometry.html">traceon.geometry</a></code> module. Currently only electrostatic excitations are supported.</p>
<p>The possible excitations are as follows:</p>
<ul>
<li>Fixed voltage (electrode connect to a power supply)</li>
<li>Voltage function (a generic Python function specifies the voltage as a function of position)</li>
<li>Dielectric, with arbitrary electric permittivity</li>
<li>Floating conductor, with an arbitrary total charge on the surface</li>
</ul>
<p>Once the excitation is specified, it can be passed to <code><a title="traceon.solver.solve_bem" href="solver.html#traceon.solver.solve_bem">solve_bem()</a></code> to compute the resulting field.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the `traceon.geometry` module. Currently only electrostatic excitations are supported.

The possible excitations are as follows:

- Fixed voltage (electrode connect to a power supply)
- Voltage function (a generic Python function specifies the voltage as a function of position)
- Dielectric, with arbitrary electric permittivity
- Floating conductor, with an arbitrary total charge on the surface

Once the excitation is specified, it can be passed to `traceon.solver.solve_bem` to compute the resulting field.
&#34;&#34;&#34;


from enum import IntEnum

import numpy as np

from .geometry import Symmetry
from .backend import N_QUAD_2D

class ExcitationType(IntEnum):
    &#34;&#34;&#34;Possible excitation that can be applied to elements of the geometry. See the methods of `Excitation` for documentation.&#34;&#34;&#34;
    VOLTAGE_FIXED = 1
    VOLTAGE_FUN = 2
    DIELECTRIC = 3
    FLOATING_CONDUCTOR = 4

    def __str__(self):
        if self == ExcitationType.VOLTAGE_FIXED:
            return &#39;voltage fixed&#39;
        elif self == ExcitationType.VOLTAGE_FUN:
            return &#39;voltage function&#39;
        elif self == ExcitationType.DIELECTRIC:
            return &#39;dielectric&#39;
        elif self == ExcitationType.FLOATING_CONDUCTOR:
            return &#39;floating conductor&#39;


class Excitation:
    &#34;&#34;&#34; &#34;&#34;&#34;
     
    def __init__(self, mesh):
        self.mesh = mesh
        self.electrodes = mesh.get_electrodes()
        self.excitation_types = {}
    
    def __str__(self):
        return f&#39;&lt;Traceon Excitation,\n\t&#39; \
            + &#39;\n\t&#39;.join([f&#39;{n}={v} ({t})&#39; for n, (t, v) in self.excitation_types.items()]) \
            + &#39;&gt;&#39;
     
    def add_voltage(self, **kwargs):
        &#34;&#34;&#34;
        Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
            calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
            Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
            Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
        
        &#34;&#34;&#34;
        for name, voltage in kwargs.items():
            assert name in self.electrodes
            if isinstance(voltage, int) or isinstance(voltage, float):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
            elif callable(voltage):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
            else:
                raise NotImplementedError(&#39;Unrecognized voltage value&#39;)

    def add_dielectric(self, **kwargs):
        &#34;&#34;&#34;
        Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
            calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
         
        &#34;&#34;&#34;
        for name, permittivity in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)

    def add_boundary(self, *args):
        &#34;&#34;&#34;
        Specify geometry elements as boundary elements. At the boundary we require EÂ·n = 0 at every point on the boundary. This
        is equivalent to stating that the directional derivative of the potential through the boundary is zero. Placing boundaries between
        the spaces of electrodes usually helps convergence tremendously. Note that a boundary is equivalent to a dielectric with a dielectric
        constant of zero. This is how a boundary is actually implemented internally.
        
        Parameters
        ----------
        *args: list of str
            The geometry names that should be considered a boundary.
        &#34;&#34;&#34;
        self.add_dielectric(**{a:0 for a in args})

    def add_floating_conductor(self, **kwargs):
        &#34;&#34;&#34;
        Specify geometric elements as floating conductors, and specify the total charge on the conductor.
         
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
            calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
            a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
            
        &#34;&#34;&#34;
        for name, charge in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)
     
    def _split_for_superposition(self):
        
        # Names that have a fixed voltage excitation, not equal to 0.0
        types = self.excitation_types
        non_zero_fixed = [n for n, (t, v) in types.items() if t == ExcitationType.VOLTAGE_FIXED and v != 0.0]
        
        excitations = []
         
        for name in non_zero_fixed:

            new_types_dict = {}
             
            for n, (t, v) in types.items():
                assert t != ExcitationType.VOLTAGE_FUN, &#34;VOLTAGE_FUN excitation not supported for superposition.&#34;
                assert (t != ExcitationType.FLOATING_CONDUCTOR or v == 0.0), &#34;FLOATING_CONDUCTOR only supported in superposition if total charge equals zero.&#34;
                 
                if n == name:
                    new_types_dict[n] = (t, 1.0)
                elif t == ExcitationType.VOLTAGE_FIXED:
                    new_types_dict[n] = (t, 0.0)
                else:
                    new_types_dict[n] = (t, v)
            
            exc = Excitation(self.mesh)
            exc.excitation_types = new_types_dict
            excitations.append(exc)

        assert len(non_zero_fixed) == len(excitations)
        return {n:e for (n,e) in zip(non_zero_fixed, excitations)}

    def get_active_element_mask(self):
        inactive = np.full(len(self.mesh.elements), True)
        names = {}
         
        for name in self.excitation_types.keys():
            inactive[ self.mesh.physical_to_elements[name] ] = False
        
        return ~inactive
     
    def get_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. 
    
        Returns
        --------
        A tuple of two elements: (points, names). points is a Numpy array of shape (N, 4, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
        This array contains the vertices of the line elements or the triangles. \
        Multiple points per line elements are used in the case of 2D since higher order BEM is employed, in which the true position on the line \
        element is given by a polynomial interpolation of the points. \
        names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
        while the values are Numpy arrays of indices that can be used to index the points array.
        &#34;&#34;&#34;
        vertices = self.mesh.elements
        inactive = ~self.get_active_element_mask() 
        map_index = np.arange(len(vertices)) - np.cumsum(inactive)
        names = {n:map_index[i] for n, i in self.mesh.physical_to_elements.items() if n in self.excitation_types}
         
        return self.mesh.points[ vertices[~inactive] ], names
    
    def get_number_of_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. This is the length of the points
        array returned by the `Excitation.get_active_elements`.

        Returns
        --------
        int, giving the number of elements. &#34;&#34;&#34;
        return sum(len(self.mesh.physical_to_elements[n]) for n in self.excitation_types.keys())

    def get_number_of_matrix_elements(self):
        &#34;&#34;&#34;Gets the number of elements along one axis of the matrix. If this function returns N, the
        matrix will have size NxN. The matrix consists of 64bit float values. Therefore the size of the matrix
        in bytes is 8Â·NxN.

        Returns
        ---------
        integer number
        &#34;&#34;&#34;
         
        Nfloating = len([name for name, (type_, _) in self.excitation_types.items() if type_ == ExcitationType.FLOATING_CONDUCTOR])
        Nelem = self.get_number_of_active_elements()
         
        if self.mesh.symmetry == Symmetry.RADIAL:
            return Nelem*N_QUAD_2D + Nfloating
        elif self.mesh.symmetry == Symmetry.THREE_D:
            return Nelem + Nfloating



        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="traceon.excitation.Excitation"><code class="flex name class">
<span>class <span class="ident">Excitation</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Excitation:
    &#34;&#34;&#34; &#34;&#34;&#34;
     
    def __init__(self, mesh):
        self.mesh = mesh
        self.electrodes = mesh.get_electrodes()
        self.excitation_types = {}
    
    def __str__(self):
        return f&#39;&lt;Traceon Excitation,\n\t&#39; \
            + &#39;\n\t&#39;.join([f&#39;{n}={v} ({t})&#39; for n, (t, v) in self.excitation_types.items()]) \
            + &#39;&gt;&#39;
     
    def add_voltage(self, **kwargs):
        &#34;&#34;&#34;
        Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
            calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
            Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
            Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
        
        &#34;&#34;&#34;
        for name, voltage in kwargs.items():
            assert name in self.electrodes
            if isinstance(voltage, int) or isinstance(voltage, float):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
            elif callable(voltage):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
            else:
                raise NotImplementedError(&#39;Unrecognized voltage value&#39;)

    def add_dielectric(self, **kwargs):
        &#34;&#34;&#34;
        Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
            calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
         
        &#34;&#34;&#34;
        for name, permittivity in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)

    def add_boundary(self, *args):
        &#34;&#34;&#34;
        Specify geometry elements as boundary elements. At the boundary we require EÂ·n = 0 at every point on the boundary. This
        is equivalent to stating that the directional derivative of the potential through the boundary is zero. Placing boundaries between
        the spaces of electrodes usually helps convergence tremendously. Note that a boundary is equivalent to a dielectric with a dielectric
        constant of zero. This is how a boundary is actually implemented internally.
        
        Parameters
        ----------
        *args: list of str
            The geometry names that should be considered a boundary.
        &#34;&#34;&#34;
        self.add_dielectric(**{a:0 for a in args})

    def add_floating_conductor(self, **kwargs):
        &#34;&#34;&#34;
        Specify geometric elements as floating conductors, and specify the total charge on the conductor.
         
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
            calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
            a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
            
        &#34;&#34;&#34;
        for name, charge in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)
     
    def _split_for_superposition(self):
        
        # Names that have a fixed voltage excitation, not equal to 0.0
        types = self.excitation_types
        non_zero_fixed = [n for n, (t, v) in types.items() if t == ExcitationType.VOLTAGE_FIXED and v != 0.0]
        
        excitations = []
         
        for name in non_zero_fixed:

            new_types_dict = {}
             
            for n, (t, v) in types.items():
                assert t != ExcitationType.VOLTAGE_FUN, &#34;VOLTAGE_FUN excitation not supported for superposition.&#34;
                assert (t != ExcitationType.FLOATING_CONDUCTOR or v == 0.0), &#34;FLOATING_CONDUCTOR only supported in superposition if total charge equals zero.&#34;
                 
                if n == name:
                    new_types_dict[n] = (t, 1.0)
                elif t == ExcitationType.VOLTAGE_FIXED:
                    new_types_dict[n] = (t, 0.0)
                else:
                    new_types_dict[n] = (t, v)
            
            exc = Excitation(self.mesh)
            exc.excitation_types = new_types_dict
            excitations.append(exc)

        assert len(non_zero_fixed) == len(excitations)
        return {n:e for (n,e) in zip(non_zero_fixed, excitations)}

    def get_active_element_mask(self):
        inactive = np.full(len(self.mesh.elements), True)
        names = {}
         
        for name in self.excitation_types.keys():
            inactive[ self.mesh.physical_to_elements[name] ] = False
        
        return ~inactive
     
    def get_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. 
    
        Returns
        --------
        A tuple of two elements: (points, names). points is a Numpy array of shape (N, 4, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
        This array contains the vertices of the line elements or the triangles. \
        Multiple points per line elements are used in the case of 2D since higher order BEM is employed, in which the true position on the line \
        element is given by a polynomial interpolation of the points. \
        names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
        while the values are Numpy arrays of indices that can be used to index the points array.
        &#34;&#34;&#34;
        vertices = self.mesh.elements
        inactive = ~self.get_active_element_mask() 
        map_index = np.arange(len(vertices)) - np.cumsum(inactive)
        names = {n:map_index[i] for n, i in self.mesh.physical_to_elements.items() if n in self.excitation_types}
         
        return self.mesh.points[ vertices[~inactive] ], names
    
    def get_number_of_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. This is the length of the points
        array returned by the `Excitation.get_active_elements`.

        Returns
        --------
        int, giving the number of elements. &#34;&#34;&#34;
        return sum(len(self.mesh.physical_to_elements[n]) for n in self.excitation_types.keys())

    def get_number_of_matrix_elements(self):
        &#34;&#34;&#34;Gets the number of elements along one axis of the matrix. If this function returns N, the
        matrix will have size NxN. The matrix consists of 64bit float values. Therefore the size of the matrix
        in bytes is 8Â·NxN.

        Returns
        ---------
        integer number
        &#34;&#34;&#34;
         
        Nfloating = len([name for name, (type_, _) in self.excitation_types.items() if type_ == ExcitationType.FLOATING_CONDUCTOR])
        Nelem = self.get_number_of_active_elements()
         
        if self.mesh.symmetry == Symmetry.RADIAL:
            return Nelem*N_QUAD_2D + Nfloating
        elif self.mesh.symmetry == Symmetry.THREE_D:
            return Nelem + Nfloating</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="traceon.excitation.Excitation.add_boundary"><code class="name flex">
<span>def <span class="ident">add_boundary</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify geometry elements as boundary elements. At the boundary we require EÂ·n = 0 at every point on the boundary. This
is equivalent to stating that the directional derivative of the potential through the boundary is zero. Placing boundaries between
the spaces of electrodes usually helps convergence tremendously. Note that a boundary is equivalent to a dielectric with a dielectric
constant of zero. This is how a boundary is actually implemented internally.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The geometry names that should be considered a boundary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_boundary(self, *args):
    &#34;&#34;&#34;
    Specify geometry elements as boundary elements. At the boundary we require EÂ·n = 0 at every point on the boundary. This
    is equivalent to stating that the directional derivative of the potential through the boundary is zero. Placing boundaries between
    the spaces of electrodes usually helps convergence tremendously. Note that a boundary is equivalent to a dielectric with a dielectric
    constant of zero. This is how a boundary is actually implemented internally.
    
    Parameters
    ----------
    *args: list of str
        The geometry names that should be considered a boundary.
    &#34;&#34;&#34;
    self.add_dielectric(**{a:0 for a in args})</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.add_dielectric"><code class="name flex">
<span>def <span class="ident">add_dielectric</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
calling the function as <code>add_dielectric(spacer=2)</code> assign the relative dielectric constant of 2 to the <code>spacer</code> physical group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dielectric(self, **kwargs):
    &#34;&#34;&#34;
    Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
    
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
        calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
     
    &#34;&#34;&#34;
    for name, permittivity in kwargs.items():
        assert name in self.electrodes
        self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.add_floating_conductor"><code class="name flex">
<span>def <span class="ident">add_floating_conductor</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify geometric elements as floating conductors, and specify the total charge on the conductor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
calling the function as <code>add_floating_conductor(spacer=10)</code> specifies the physical group <code>spacer</code> as a floating conductor with
a total charge on its surface equal to 10. For the unit of charge, see the section 'Units' on the <code><a title="traceon" href="index.html">traceon</a></code> page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_floating_conductor(self, **kwargs):
    &#34;&#34;&#34;
    Specify geometric elements as floating conductors, and specify the total charge on the conductor.
     
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
        calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
        a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
        
    &#34;&#34;&#34;
    for name, charge in kwargs.items():
        assert name in self.electrodes
        self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.add_voltage"><code class="name flex">
<span>def <span class="ident">add_voltage</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
calling the function as <code>add_voltage(lens=50)</code> assigns a 50V value to the geometry elements part of the 'lens' physical group.
Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_voltage(self, **kwargs):
    &#34;&#34;&#34;
    Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
    
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
        calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
        Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
        Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
    
    &#34;&#34;&#34;
    for name, voltage in kwargs.items():
        assert name in self.electrodes
        if isinstance(voltage, int) or isinstance(voltage, float):
            self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
        elif callable(voltage):
            self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
        else:
            raise NotImplementedError(&#39;Unrecognized voltage value&#39;)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_active_element_mask"><code class="name flex">
<span>def <span class="ident">get_active_element_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_active_element_mask(self):
    inactive = np.full(len(self.mesh.elements), True)
    names = {}
     
    for name in self.excitation_types.keys():
        inactive[ self.mesh.physical_to_elements[name] ] = False
    
    return ~inactive</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_active_elements"><code class="name flex">
<span>def <span class="ident">get_active_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get elements in the mesh that are active, in the sense that
an excitation to them has been applied. </p>
<h2 id="returns">Returns</h2>
<p>A tuple of two elements: (points, names). points is a Numpy array of shape (N, 4, 3) in the case of 2D and (N, 3, 3) in the case of 3D.
This array contains the vertices of the line elements or the triangles.
Multiple points per line elements are used in the case of 2D since higher order BEM is employed, in which the true position on the line
element is given by a polynomial interpolation of the points.
names is a dictionary, the keys being the names of the physical groups mentioned by this excitation,
while the values are Numpy arrays of indices that can be used to index the points array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_active_elements(self):
    &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
    an excitation to them has been applied. 

    Returns
    --------
    A tuple of two elements: (points, names). points is a Numpy array of shape (N, 4, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
    This array contains the vertices of the line elements or the triangles. \
    Multiple points per line elements are used in the case of 2D since higher order BEM is employed, in which the true position on the line \
    element is given by a polynomial interpolation of the points. \
    names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
    while the values are Numpy arrays of indices that can be used to index the points array.
    &#34;&#34;&#34;
    vertices = self.mesh.elements
    inactive = ~self.get_active_element_mask() 
    map_index = np.arange(len(vertices)) - np.cumsum(inactive)
    names = {n:map_index[i] for n, i in self.mesh.physical_to_elements.items() if n in self.excitation_types}
     
    return self.mesh.points[ vertices[~inactive] ], names</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_number_of_active_elements"><code class="name flex">
<span>def <span class="ident">get_number_of_active_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get elements in the mesh that are active, in the sense that
an excitation to them has been applied. This is the length of the points
array returned by the <code><a title="traceon.excitation.Excitation.get_active_elements" href="#traceon.excitation.Excitation.get_active_elements">Excitation.get_active_elements()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>int, giving the number of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_active_elements(self):
    &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
    an excitation to them has been applied. This is the length of the points
    array returned by the `Excitation.get_active_elements`.

    Returns
    --------
    int, giving the number of elements. &#34;&#34;&#34;
    return sum(len(self.mesh.physical_to_elements[n]) for n in self.excitation_types.keys())</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_number_of_matrix_elements"><code class="name flex">
<span>def <span class="ident">get_number_of_matrix_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the number of elements along one axis of the matrix. If this function returns N, the
matrix will have size NxN. The matrix consists of 64bit float values. Therefore the size of the matrix
in bytes is 8Â·NxN.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer number</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_matrix_elements(self):
    &#34;&#34;&#34;Gets the number of elements along one axis of the matrix. If this function returns N, the
    matrix will have size NxN. The matrix consists of 64bit float values. Therefore the size of the matrix
    in bytes is 8Â·NxN.

    Returns
    ---------
    integer number
    &#34;&#34;&#34;
     
    Nfloating = len([name for name, (type_, _) in self.excitation_types.items() if type_ == ExcitationType.FLOATING_CONDUCTOR])
    Nelem = self.get_number_of_active_elements()
     
    if self.mesh.symmetry == Symmetry.RADIAL:
        return Nelem*N_QUAD_2D + Nfloating
    elif self.mesh.symmetry == Symmetry.THREE_D:
        return Nelem + Nfloating</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="traceon.excitation.ExcitationType"><code class="flex name class">
<span>class <span class="ident">ExcitationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Possible excitation that can be applied to elements of the geometry. See the methods of <code><a title="traceon.excitation.Excitation" href="#traceon.excitation.Excitation">Excitation</a></code> for documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExcitationType(IntEnum):
    &#34;&#34;&#34;Possible excitation that can be applied to elements of the geometry. See the methods of `Excitation` for documentation.&#34;&#34;&#34;
    VOLTAGE_FIXED = 1
    VOLTAGE_FUN = 2
    DIELECTRIC = 3
    FLOATING_CONDUCTOR = 4

    def __str__(self):
        if self == ExcitationType.VOLTAGE_FIXED:
            return &#39;voltage fixed&#39;
        elif self == ExcitationType.VOLTAGE_FUN:
            return &#39;voltage function&#39;
        elif self == ExcitationType.DIELECTRIC:
            return &#39;dielectric&#39;
        elif self == ExcitationType.FLOATING_CONDUCTOR:
            return &#39;floating conductor&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="traceon.excitation.ExcitationType.DIELECTRIC"><code class="name">var <span class="ident">DIELECTRIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.FLOATING_CONDUCTOR"><code class="name">var <span class="ident">FLOATING_CONDUCTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.VOLTAGE_FIXED"><code class="name">var <span class="ident">VOLTAGE_FIXED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.VOLTAGE_FUN"><code class="name">var <span class="ident">VOLTAGE_FUN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="traceon" href="index.html">traceon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="traceon.excitation.Excitation" href="#traceon.excitation.Excitation">Excitation</a></code></h4>
<ul class="">
<li><code><a title="traceon.excitation.Excitation.add_boundary" href="#traceon.excitation.Excitation.add_boundary">add_boundary</a></code></li>
<li><code><a title="traceon.excitation.Excitation.add_dielectric" href="#traceon.excitation.Excitation.add_dielectric">add_dielectric</a></code></li>
<li><code><a title="traceon.excitation.Excitation.add_floating_conductor" href="#traceon.excitation.Excitation.add_floating_conductor">add_floating_conductor</a></code></li>
<li><code><a title="traceon.excitation.Excitation.add_voltage" href="#traceon.excitation.Excitation.add_voltage">add_voltage</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_active_element_mask" href="#traceon.excitation.Excitation.get_active_element_mask">get_active_element_mask</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_active_elements" href="#traceon.excitation.Excitation.get_active_elements">get_active_elements</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_number_of_active_elements" href="#traceon.excitation.Excitation.get_number_of_active_elements">get_number_of_active_elements</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_number_of_matrix_elements" href="#traceon.excitation.Excitation.get_number_of_matrix_elements">get_number_of_matrix_elements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="traceon.excitation.ExcitationType" href="#traceon.excitation.ExcitationType">ExcitationType</a></code></h4>
<ul class="">
<li><code><a title="traceon.excitation.ExcitationType.DIELECTRIC" href="#traceon.excitation.ExcitationType.DIELECTRIC">DIELECTRIC</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.FLOATING_CONDUCTOR" href="#traceon.excitation.ExcitationType.FLOATING_CONDUCTOR">FLOATING_CONDUCTOR</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.VOLTAGE_FIXED" href="#traceon.excitation.ExcitationType.VOLTAGE_FIXED">VOLTAGE_FIXED</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.VOLTAGE_FUN" href="#traceon.excitation.ExcitationType.VOLTAGE_FUN">VOLTAGE_FUN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>