<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>traceon.geometry API documentation</title>
<meta name="description" content="The geometry module allows the creation of general meshes in 2D and 3D.
The builtin mesher uses so called _parametric_ meshes, meaning
that for any â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>traceon.geometry</code></h1>
</header>
<section id="section-intro">
<p>The geometry module allows the creation of general meshes in 2D and 3D.
The builtin mesher uses so called <em>parametric</em> meshes, meaning
that for any mesh we construct a mathematical formula mapping to points on the mesh. This makes it
easy to generate structured (or transfinite) meshes. These meshes usually help the mesh to converge
to the right answer faster, since the symmetries of the mesh (radial, multipole, etc.) are better
represented. </p>
<p>The parametric mesher also has downsides, since it's for example harder to generate meshes with
lots of holes in them (the 'cut' operation is not supported). For these cases, Traceon makes it easy to import
meshes generated by other programs (e.g. GMSH or Comsol). Traceon can import <a href="https://github.com/nschloe/meshio">meshio</a> meshes
or any file format supported by meshio.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="traceon.geometry.Path"><code class="flex name class">
<span>class <span class="ident">Path</span></span>
<span>(</span><span>fun, path_length, breakpoints=[], name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A path is a mapping from a number in the range [0, path_length] to a three dimensional point. Note that <code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code> is a
subclass of <code><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></code>, and therefore can be easily moved and rotated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Path(GeometricObject):
    &#34;&#34;&#34;A path is a mapping from a number in the range [0, path_length] to a three dimensional point. Note that `Path` is a
    subclass of `traceon.mesher.GeometricObject`, and therefore can be easily moved and rotated.&#34;&#34;&#34;
    
    def __init__(self, fun, path_length, breakpoints=[], name=None):
        # Assumption: fun takes in p, the path length
        # and returns the point on the path
        self.fun = fun
        self.path_length = path_length
        self.breakpoints = breakpoints
        self.name = name
    
    @staticmethod
    def from_irregular_function(to_point, N=100, breakpoints=[]):
        &#34;&#34;&#34;Construct a path from a function that is of the form u -&gt; point, where 0 &lt;= u &lt;= 1.
        The length of the path is determined by integration.

        Parameters
        ---------------------------------
        to_point: callable
            A function accepting a number in the range [0, 1] and returns a the dimensional point.
        N: int
            Number of samples to use in the cubic spline interpolation.
        breakpoints: float iterable
            Points (0 &lt;= u &lt;= 1) on the path where the function is non-differentiable. These points
            are always included in the resulting mesh.

        Returns
        ---------------------------------
        Path&#34;&#34;&#34;
         
        # path length = integrate |f&#39;(x)|
        fun = lambda u: np.array(to_point(u))
        
        u = np.linspace(0, 1, N)
        samples = CubicSpline(u, [fun(u_) for u_ in u])
        derivatives = samples.derivative()(u)
        norm_derivatives = np.linalg.norm(derivatives, axis=1)
        path_lengths = CubicSpline(u, norm_derivatives).antiderivative()(u)
        interpolation = CubicSpline(path_lengths, u) # Path length to [0,1]

        path_length = path_lengths[-1]
        
        return Path(lambda pl: fun(interpolation(pl)), path_length, breakpoints=[b*path_length for b in breakpoints])
    
    @staticmethod
    def spline_through_points(points, N=100):
        &#34;&#34;&#34;Construct a path by fitting a cubic spline through the given points.

        Parameters
        -------------------------
        points: (N, 3) ndarray of float
            Three dimensional points through which the spline is fitted.

        Returns
        -------------------------
        Path&#34;&#34;&#34;

        x = np.linspace(0, 1, len(points))
        interp = CubicSpline(x, points)
        return Path.from_irregular_function(interp, N=N)
     
    def average(self, fun):
        &#34;&#34;&#34;Average a function along the path, by integrating 1/l * fun(path(l)) with 0 &lt;= l &lt;= path length.

        Parameters
        --------------------------
        fun: callable (3,) -&gt; float
            A function taking a three dimensional point and returning a float.

        Returns
        -------------------------
        float

        The average value of the function along the point.&#34;&#34;&#34;
        return quad(lambda s: fun(self(s)), 0, self.path_length, points=self.breakpoints)[0]/self.path_length
     
    def map_points(self, fun):
        &#34;&#34;&#34;Return a new function by mapping a function over points along the path (see `traceon.mesher.GeometricObject`).
        The path length is assumed to stay the same after this operation.
        
        Parameters
        ----------------------------
        fun: callable (3,) -&gt; (3,)
            Function taking three dimensional points and returning three dimensional points.

        Returns
        ---------------------------      

        Path&#34;&#34;&#34;
        return Path(lambda u: fun(self(u)), self.path_length, self.breakpoints, name=self.name)
     
    def __call__(self, t):
        &#34;&#34;&#34;Evaluate a point along the path.

        Parameters
        ------------------------
        t: float
            The length along the path.

        Returns
        ------------------------
        (3,) float

        Three dimensional point.&#34;&#34;&#34;
        return self.fun(t)
     
    def is_closed(self):
        &#34;&#34;&#34;Determine whether the path is closed, by comparing the starting and endpoint.

        Returns
        ----------------------
        bool: True if the path is closed, False otherwise.&#34;&#34;&#34;
        return _points_close(self.starting_point(), self.endpoint())
    
    def add_phase(self, l):
        &#34;&#34;&#34;Add a phase to a closed path. A path is closed when the starting point is equal to the
        end point. A phase of length l means that the path starts &#39;further down&#39; the closed path.

        Parameters
        --------------------
        l: float
            The phase (expressed as a path length). The resulting path starts l distance along the 
            original path.

        Returns
        --------------------
        Path&#34;&#34;&#34;
        assert self.is_closed()
        
        def fun(u):
            return self( (l + u) % self.path_length )
        
        return Path(fun, self.path_length, sorted([(b-l)%self.path_length for b in self.breakpoints + [0.]]), name=self.name)
     
    def __rshift__(self, other):
        &#34;&#34;&#34;Combine two paths to create a single path. The endpoint of the first path needs
        to match the starting point of the second path. This common point is marked as a breakpoint and
        always included in the mesh. To use this function use the right shift operator (p1 &gt;&gt; p2).

        Parameters
        -----------------------
        other: Path
            The second path, to extend the current path.

        Returns
        -----------------------
        Path&#34;&#34;&#34;

        assert isinstance(other, Path), &#34;Exteding path with object that is not actually a Path&#34;

        assert _points_close(self.endpoint(), other.starting_point())

        total = self.path_length + other.path_length
         
        def f(t):
            assert 0 &lt;= t &lt;= total
            
            if t &lt;= self.path_length:
                return self(t)
            else:
                return other(t - self.path_length)
        
        return Path(f, total, self.breakpoints + [self.path_length] + other.breakpoints, name=self.name)

    def starting_point(self):
        &#34;&#34;&#34;Returns the starting point of the path.

        Returns
        ---------------------
        (3,) float

        The starting point of the path.&#34;&#34;&#34;
        return self(0.)
    
    def middle_point(self):
        &#34;&#34;&#34;Returns the midpoint of the path (in terms of length along the path.)

        Returns
        ----------------------
        (3,) float
        
        The point at the middle of the path.&#34;&#34;&#34;
        return self(self.path_length/2)
    
    def endpoint(self):
        &#34;&#34;&#34;Returns the endpoint of the path.

        Returns
        ------------------------
        (3,) float
        
        The endpoint of the path.&#34;&#34;&#34;
        return self(self.path_length)
    
    def line_to(self, point):
        &#34;&#34;&#34;Extend the current path by a line from the current endpoint to the given point.
        The given point is marked a breakpoint.

        Parameters
        ----------------------
        point: (3,) float
            The new endpoint.

        Returns
        ---------------------
        Path&#34;&#34;&#34;
        warnings.warn(&#34;line_to() is deprecated and will be removed in version 0.8.0.&#34;
        &#34;Use extend_with_line() instead.&#34;,
        DeprecationWarning,
        stacklevel=2)

        point = np.array(point)
        assert point.shape == (3,), &#34;Please supply a three dimensional point to .line_to(...)&#34;
        l = Path.line(self.endpoint(), point)
        return self &gt;&gt; l
    
    def extend_with_line(self, point):
        &#34;&#34;&#34;Extend the current path by a line from the current endpoint to the given point.
        The given point is marked a breakpoint.

        Parameters
        ----------------------
        point: (3,) float
            The new endpoint.

        Returns
        ---------------------
        Path&#34;&#34;&#34;
        point = np.array(point)
        assert point.shape == (3,), &#34;Please supply a three dimensional point to .extend_with_line(...)&#34;
        l = Path.line(self.endpoint(), point)
        return self &gt;&gt; l
     
    @staticmethod
    def circle_xz(x0, z0, radius, angle=2*pi):
        &#34;&#34;&#34;Returns (part of) a circle in the XZ plane around the x-axis. Starting on the positive x-axis.
        
        Parameters
        --------------------------------
        x0: float
            x-coordinate of the center of the circle
        z0: float
            z-coordinate of the center of the circle
        radius: float
            radius of the circle
        angle: float
            The circumference of the circle in radians. The default of 2*pi gives a full circle.

        Returns
        ---------------------------------
        Path&#34;&#34;&#34;
        def f(u):
            theta = u / radius 
            return np.array([radius*cos(theta), 0., radius*sin(theta)])
        return Path(f, angle*radius).move(dx=x0, dz=z0)
    
    @staticmethod
    def circle_yz(y0, z0, radius, angle=2*pi):
        &#34;&#34;&#34;Returns (part of) a circle in the YZ plane around the x-axis. Starting on the positive y-axis.
        
        Parameters
        --------------------------------
        y0: float
            x-coordinate of the center of the circle
        z0: float
            z-coordinate of the center of the circle
        radius: float
            radius of the circle
        angle: float
            The circumference of the circle in radians. The default of 2*pi gives a full circle.

        Returns
        ---------------------------------
        Path&#34;&#34;&#34;
        def f(u):
            theta = u / radius 
            return np.array([0., radius*cos(theta), radius*sin(theta)])
        return Path(f, angle*radius).move(dy=y0, dz=z0)
    
    @staticmethod
    def circle_xy(x0, y0, radius, angle=2*pi):
        &#34;&#34;&#34;Returns (part of) a circle in the XY plane around the z-axis. Starting on the positive X-axis.
        
        Parameters
        --------------------------------
        x0: float
            x-coordinate of the center of the circle
        y0: float
            y-coordinate of the center of the circle
        radius: float
            radius of the circle
        angle: float
            The circumference of the circle in radians. The default of 2*pi gives a full circle.

        Returns
        ---------------------------------
        Path&#34;&#34;&#34;
        def f(u):
            theta = u / radius 
            return np.array([radius*cos(theta), radius*sin(theta), 0.])
        return Path(f, angle*radius).move(dx=x0, dy=y0)
     
    def arc_to(self, center, end, reverse=False):
        &#34;&#34;&#34;Extend the current path using an arc.

        Parameters
        ----------------------------
        center: (3,) float
            The center point of the arc.
        end: (3,) float
            The endpoint of the arc, shoud lie on a circle determined
            by the given centerpoint and the current endpoint.

        Returns
        -----------------------------
        Path&#34;&#34;&#34;
        warnings.warn(&#34;arc_to() is deprecated and will be removed in version 0.8.0.&#34;
        &#34;Use extend_with_arc() instead.&#34;,
        DeprecationWarning,
        stacklevel=2)

        start = self.endpoint()
        return self &gt;&gt; Path.arc(center, start, end, reverse=reverse)
    
    def extend_with_arc(self, center, end, reverse=False):
        &#34;&#34;&#34;Extend the current path using an arc.

        Parameters
        ----------------------------
        center: (3,) float
            The center point of the arc.
        end: (3,) float
            The endpoint of the arc, shoud lie on a circle determined
            by the given centerpoint and the current endpoint.

        Returns
        -----------------------------
        Path&#34;&#34;&#34;
        start = self.endpoint()
        return self &gt;&gt; Path.arc(center, start, end, reverse=reverse)
    
    @staticmethod
    def arc(center, start, end, reverse=False):
        &#34;&#34;&#34;Return an arc by specifying the center, start and end point.

        Parameters
        ----------------------------
        center: (3,) float
            The center point of the arc.
        start: (3,) float
            The start point of the arc.
        end: (3,) float
            The endpoint of the arc.

        Returns
        ----------------------------
        Path&#34;&#34;&#34;
        start_arr, center_arr, end_arr = np.array(start), np.array(center), np.array(end)
         
        x_unit = start_arr - center_arr
        x_unit /= np.linalg.norm(x_unit)

        vector = end_arr - center_arr
         
        y_unit = vector - np.dot(vector, x_unit) * x_unit
        y_unit /= np.linalg.norm(y_unit)

        radius = np.linalg.norm(start_arr - center_arr) 
        theta_max = atan2(np.dot(vector, y_unit), np.dot(vector, x_unit))

        if reverse:
            theta_max = theta_max - 2*pi

        path_length = abs(theta_max * radius)
          
        def f(l):
            theta = l/path_length * theta_max
            return center + radius*cos(theta)*x_unit + radius*sin(theta)*y_unit
        
        return Path(f, path_length)
     
    def revolve_x(self, angle=2*pi):
        &#34;&#34;&#34;Create a surface by revolving the path anti-clockwise around the x-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.

        Returns
        -----------------------
        Surface&#34;&#34;&#34;
        
        r_avg = self.average(lambda p: sqrt(p[1]**2 + p[2]**2))
        length2 = 2*pi*r_avg
         
        def f(u, v):
            p = self(u)
            theta = atan2(p[2], p[1])
            r = sqrt(p[1]**2 + p[2]**2)
            return np.array([p[0], r*cos(theta + v/length2*angle), r*sin(theta + v/length2*angle)])
         
        return Surface(f, self.path_length, length2, self.breakpoints, name=self.name)
    
    def revolve_y(self, angle=2*pi):
        &#34;&#34;&#34;Create a surface by revolving the path anti-clockwise around the y-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.

        Returns
        -----------------------
        Surface&#34;&#34;&#34;

        r_avg = self.average(lambda p: sqrt(p[0]**2 + p[2]**2))
        length2 = 2*pi*r_avg
         
        def f(u, v):
            p = self(u)
            theta = atan2(p[2], p[0])
            r = sqrt(p[0]*p[0] + p[2]*p[2])
            return np.array([r*cos(theta + v/length2*angle), p[1], r*sin(theta + v/length2*angle)])
         
        return Surface(f, self.path_length, length2, self.breakpoints, name=self.name)
    
    def revolve_z(self, angle=2*pi):
        &#34;&#34;&#34;Create a surface by revolving the path anti-clockwise around the z-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.

        Returns
        -----------------------
        Surface&#34;&#34;&#34;

        r_avg = self.average(lambda p: sqrt(p[0]**2 + p[1]**2))
        length2 = 2*pi*r_avg
        
        def f(u, v):
            p = self(u)
            theta = atan2(p[1], p[0])
            r = sqrt(p[0]*p[0] + p[1]*p[1])
            return np.array([r*cos(theta + v/length2*angle), r*sin(theta + v/length2*angle), p[2]])
        
        return Surface(f, self.path_length, length2, self.breakpoints, name=self.name)
     
    def extrude(self, vector):
        &#34;&#34;&#34;Create a surface by extruding the path along a vector. The vector gives both
        the length and the direction of the extrusion.

        Parameters
        -------------------------
        vector: (3,) float
            The direction and length (norm of the vector) to extrude by.

        Returns
        -------------------------
        Surface&#34;&#34;&#34;
        vector = np.array(vector)
        length = np.linalg.norm(vector)
         
        def f(u, v):
            return self(u) + v/length*vector
        
        return Surface(f, self.path_length, length, self.breakpoints, name=self.name)
    
    def extrude_by_path(self, p2):
        &#34;&#34;&#34;Create a surface by extruding the path along a second path. The second
        path does not need to start along the first path. Imagine the surface created
        by moving the first path along the second path.

        Parameters
        -------------------------
        p2: Path
            The (second) path defining the extrusion.

        Returns
        ------------------------
        Surface&#34;&#34;&#34;
        p0 = p2.starting_point()
         
        def f(u, v):
            return self(u) + p2(v) - p0

        return Surface(f, self.path_length, p2.path_length, self.breakpoints, p2.breakpoints, name=self.name)

    def close(self):
        &#34;&#34;&#34;Close the path, by making a straight line to the starting point.

        Returns
        -------------------
        Path&#34;&#34;&#34;
        return self.extend_with_line(self.starting_point())
    
    @staticmethod
    def ellipse(major, minor):
        &#34;&#34;&#34;Create a path along the outline of an ellipse. The ellipse lies
        in the XY plane, and the path starts on the positive x-axis.

        Parameters
        ---------------------------
        major: float
            The major axis of the ellipse (lies along the x-axis).
        minor: float
            The minor axis of the ellipse (lies along the y-axis).

        Returns
        ---------------------------
        Path&#34;&#34;&#34;
        # Crazy enough there is no closed formula
        # to go from path length to a point on the ellipse.
        # So we have to use `from_irregular_function`
        def f(u):
            return np.array([major*cos(2*pi*u), minor*sin(2*pi*u), 0.])
        return Path.from_irregular_function(f)
    
    @staticmethod
    def line(from_, to):
        &#34;&#34;&#34;Create a straight line between two points.

        Parameters
        ------------------------------
        from_: (3,) float
            The starting point of the path.
        to: (3,) float
            The endpoint of the path.

        Returns
        ---------------------------
        Path&#34;&#34;&#34;
        from_, to = np.array(from_), np.array(to)
        length = np.linalg.norm(from_ - to)
        return Path(lambda pl: (1-pl/length)*from_ + pl/length*to, length)

    def cut(self, length):
        &#34;&#34;&#34;Cut the path in two at a specific length along the path.

        Parameters
        --------------------------------------
        length: float
            The length along the path at which to cut.

        Returns
        -------------------------------------
        (Path, Path)
        
        A tuple containing two paths. The first path contains the path upto length, while the second path contains the rest.&#34;&#34;&#34;
        return (Path(self.fun, length, [b for b in self.breakpoints if b &lt;= length], name=self.name),
                Path(lambda l: self.fun(l + length), self.path_length - length, [b - length for b in self.breakpoints if b &gt;= length], name=self.name))
    
    @staticmethod
    def rectangle_xz(xmin, xmax, zmin, zmax):
        &#34;&#34;&#34;Create a rectangle in the XZ plane. The path starts at (xmin, 0, zmin), and is 
        counter clockwise around the y-axis.
        
        Parameters
        ------------------------
        xmin: float
            Minimum x-coordinate of the corner points.
        xmax: float
            Maximum x-coordinate of the corner points.
        zmin: float
            Minimum z-coordinate of the corner points.
        zmax: float
            Maximum z-coordinate of the corner points.
        
        Returns
        -----------------------
        Path&#34;&#34;&#34;
        return Path.line([xmin, 0., zmin], [xmax, 0, zmin]) \
            .extend_with_line([xmax, 0, zmax]).extend_with_line([xmin, 0., zmax]).close()
     
    @staticmethod
    def rectangle_yz(ymin, ymax, zmin, zmax):
        &#34;&#34;&#34;Create a rectangle in the YZ plane. The path starts at (0, ymin, zmin), and is 
        counter clockwise around the x-axis.
        
        Parameters
        ------------------------
        ymin: float
            Minimum y-coordinate of the corner points.
        ymax: float
            Maximum y-coordinate of the corner points.
        zmin: float
            Minimum z-coordinate of the corner points.
        zmax: float
            Maximum z-coordinate of the corner points.
        
        Returns
        -----------------------
        Path&#34;&#34;&#34;

        return Path.line([0., ymin, zmin], [0, ymin, zmax]) \
            .extend_with_line([0., ymax, zmax]).extend_with_line([0., ymax, zmin]).close()
     
    @staticmethod
    def rectangle_xy(xmin, xmax, ymin, ymax):
        &#34;&#34;&#34;Create a rectangle in the XY plane. The path starts at (xmin, ymin, 0), and is 
        counter clockwise around the z-axis.
        
        Parameters
        ------------------------
        xmin: float
            Minimum x-coordinate of the corner points.
        xmax: float
            Maximum x-coordinate of the corner points.
        ymin: float
            Minimum y-coordinate of the corner points.
        ymax: float
            Maximum y-coordinate of the corner points.
        
        Returns
        -----------------------
        Path&#34;&#34;&#34;
        return Path.line([xmin, ymin, 0.], [xmin, ymax, 0.]) \
            .extend_with_line([xmax, ymax, 0.]).extend_with_line([xmax, ymin, 0.]).close()
    
    @staticmethod
    def aperture(height, radius, extent, z=0.):
        &#34;&#34;&#34;Create an &#39;aperture&#39;. Note that in a radially symmetric geometry
        an aperture is basically a rectangle with the right side &#39;open&#39;. Revolving
        this path around the z-axis would generate a cylindircal hole in the center. 
        This is the most basic model of an aperture.

        Parameters
        ------------------------
        height: float
            The height of the aperture
        radius: float
            The radius of the aperture hole (distance to the z-axis)
        extent: float
            The maximum x value
        z: float
            The z-coordinate of the center of the aperture

        Returns
        ------------------------
        Path&#34;&#34;&#34;
        return Path.line([extent, 0., -height/2], [radius, 0., -height/2])\
                .extend_with_line([radius, 0., height/2]).extend_with_line([extent, 0., height/2]).move(dz=z)

    @staticmethod
    def polar_arc(radius, angle, start, direction, plane_normal=[0,1,0]):
        &#34;&#34;&#34;Return an arc specified by polar coordinates. The arc lies in a plane defined by the 
        provided normal vector and curves from the start point in the specified direction 
        counterclockwise around the normal.

        Parameters
        ---------------------------
        radius : float
            The radius of the arc.
        angle : float
            The angle subtended by the arc (in radians)
        start: (3,) float
            The start point of the arc
        plane_normal : (3,) float
            The normal vector of the plane containing the arc
        direction : (3,) float
            A tangent of the arc at the starting point. 
            Must lie in the specified plane. Does not need to be normalized. 
        Returns
        ----------------------------
        Path&#34;&#34;&#34;
        start = np.array(start, dtype=float)
        plane_normal = np.array(plane_normal, dtype=float)
        direction = np.array(direction, dtype=float)

        direction_unit = direction / np.linalg.norm(direction)
        plane_normal_unit = plane_normal / np.linalg.norm(plane_normal)

        if not np.isclose(np.dot(direction_unit, plane_normal_unit), 0., atol=1e-7):
            corrected_direction = direction - np.dot(direction, plane_normal_unit) * plane_normal_unit
            raise AssertionError(
                f&#34;The provided direction {direction} does not lie in the specified plane. \n&#34;
                f&#34;The closed valid direction is {np.round(corrected_direction, 10)}.&#34;)
        
        if angle &lt; 0:
            direction, angle = -direction, -angle

        center = start - radius * np.cross(direction, plane_normal)
        center_to_start = start - center
        
        def f(l):
            theta = l/radius
            return center + np.cos(theta) * center_to_start + np.sin(theta)*np.cross(plane_normal, center_to_start)
        
        return Path(f, radius*angle)
    
    def extend_with_polar_arc(self, radius, angle, plane_normal=[0, 1, 0]):
        &#34;&#34;&#34;Extend the current path by a smooth arc using polar coordinates.
        The arc is defined by a specified radius and angle and rotates counterclockwise
         around around the normal that defines the arcing plane.

        Parameters
        ---------------------------
        radius : float
            The radius of the arc
        angle : float
            The angle subtended by the arc (in radians)
        plane_normal : (3,) float
            The normal vector of the plane containing the arc

        Returns
        ----------------------------
        Path&#34;&#34;&#34;
        plane_normal = np.array(plane_normal, dtype=float)
        start_point = self.endpoint()
        direction = self.velocity_vector(self.path_length)

        plane_normal_unit = plane_normal / np.linalg.norm(plane_normal)
        direction_unit = direction / np.linalg.norm(direction)

        if not np.isclose(np.dot(plane_normal_unit, direction_unit), 0,atol=1e-7):
            corrected_normal = plane_normal - np.dot(direction_unit, plane_normal) * direction_unit
            raise AssertionError(
                f&#34;The provided plane normal {plane_normal} is not orthogonal to the direction {direction}  \n&#34;
                f&#34;of the path at the endpoint so no smooth arc can be made. The closest valid normal is &#34;
                f&#34;{np.round(corrected_normal, 10)}.&#34;)
        
        return self &gt;&gt; Path.polar_arc(radius, angle, start_point, direction, plane_normal)

    def reverse(self):
        &#34;&#34;&#34;Generate a reversed version of the current path.
        The reversed path is created by inverting the traversal direction,
        such that the start becomes the end and vice versa.

        Returns
        ----------------------------
        Path&#34;&#34;&#34;
        return Path(lambda t: self(self.path_length-t), self.path_length, 
                    [self.path_length - b for b in self.breakpoints], self.name)
    
    def velocity_vector(self, t):
        &#34;&#34;&#34;Calculate the velocity (tangent) vector at a specific point on the path 
        using cubic spline interpolation.

        Parameters
        ----------------------------
        t : float
            The point on the path at which to calculate the velocity
        num_splines : int
            The number of samples used for cubic spline interpolation

        Returns
        ----------------------------
        (3,) np.ndarray of float&#34;&#34;&#34;

        samples = np.linspace(t - self.path_length*1e-3, t + self.path_length*1e-3, 7) # Odd number to include t
        samples_on_path = [s for s in samples if 0 &lt;= s &lt;= self.path_length]
        assert len(samples_on_path), &#34;Please supply a point that lies on the path&#34;
        return CubicSpline(samples_on_path, [self(s) for s in samples_on_path])(t, nu=1)
    
   
    def __add__(self, other):
        &#34;&#34;&#34;Add two paths to create a PathCollection. Note that a PathCollection supports
        a subset of the methods of Path (for example, movement, rotation and meshing). Use
        the + operator to combine paths into a path collection: path1 + path2 + path3.

        Returns
        -------------------------
        PathCollection&#34;&#34;&#34;
         
        if isinstance(other, Path):
            return PathCollection([self, other])
        
        if isinstance(other, PathCollection):
            return PathCollection([self] + [other.paths])

        return NotImplemented
     
    def mesh(self, mesh_size=None, mesh_size_factor=None, higher_order=False, name=None, ensure_outward_normals=True):
        &#34;&#34;&#34;Mesh the path, so it can be used in the BEM solver. The result of meshing a path
        are (possibly curved) line elements.

        Parameters
        --------------------------
        mesh_size: float
            Determines amount of elements in the mesh. A smaller
            mesh size leads to more elements.
        mesh_size_factor: float
            Alternative way to specify the mesh size, which scales
            with the dimensions of the geometry, and therefore more
            easily translates between different geometries.
        higher_order: bool
            Whether to generate a higher order mesh. A higher order
            produces curved line elements (determined by 4 points on
            each curved element). The BEM solver supports higher order
            elements in radial symmetric geometries only.
        name: str
            Assign this name to the mesh, instead of the name value assinged to Surface.name
        
        Returns
        ----------------------------
        `traceon.mesher.Mesh`&#34;&#34;&#34;
        u = discretize_path(self.path_length, self.breakpoints, mesh_size, mesh_size_factor, N_factor=3 if higher_order else 1)
        
        N = len(u) 
        points = np.zeros( (N, 3) )
         
        for i in range(N):
            points[i] = self(u[i])
         
        if not higher_order:
            lines = np.array([np.arange(N-1), np.arange(1, N)]).T
        else:
            assert N % 3 == 1
            r = np.arange(N)
            p0 = r[0:-1:3]
            p1 = r[3::3]
            p2 = r[1::3]
            p3 = r[2::3]
            lines = np.array([p0, p1, p2, p3]).T
          
        assert lines.dtype == np.int64 or lines.dtype == np.int32
        
        name = self.name if name is None else name
         
        if name is not None:
            physical_to_lines = {name:np.arange(len(lines))}
        else:
            physical_to_lines = {}
        
        return Mesh(points=points, lines=lines, physical_to_lines=physical_to_lines, ensure_outward_normals=ensure_outward_normals)

    def __str__(self):
        return f&#34;&lt;Path name:{self.name}, length:{self.path_length:.1e}, number of breakpoints:{len(self.breakpoints)}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="traceon.geometry.Path.aperture"><code class="name flex">
<span>def <span class="ident">aperture</span></span>(<span>height, radius, extent, z=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an 'aperture'. Note that in a radially symmetric geometry
an aperture is basically a rectangle with the right side 'open'. Revolving
this path around the z-axis would generate a cylindircal hole in the center.
This is the most basic model of an aperture.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>The height of the aperture</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the aperture hole (distance to the z-axis)</dd>
<dt><strong><code>extent</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum x value</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The z-coordinate of the center of the aperture</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.arc"><code class="name flex">
<span>def <span class="ident">arc</span></span>(<span>center, start, end, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an arc by specifying the center, start and end point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The center point of the arc.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The start point of the arc.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The endpoint of the arc.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.circle_xy"><code class="name flex">
<span>def <span class="ident">circle_xy</span></span>(<span>x0, y0, radius, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns (part of) a circle in the XY plane around the z-axis. Starting on the positive X-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordinate of the center of the circle</dd>
<dt><strong><code>y0</code></strong> :&ensp;<code>float</code></dt>
<dd>y-coordinate of the center of the circle</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the circle</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The circumference of the circle in radians. The default of 2*pi gives a full circle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.circle_xz"><code class="name flex">
<span>def <span class="ident">circle_xz</span></span>(<span>x0, z0, radius, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns (part of) a circle in the XZ plane around the x-axis. Starting on the positive x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordinate of the center of the circle</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate of the center of the circle</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the circle</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The circumference of the circle in radians. The default of 2*pi gives a full circle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.circle_yz"><code class="name flex">
<span>def <span class="ident">circle_yz</span></span>(<span>y0, z0, radius, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns (part of) a circle in the YZ plane around the x-axis. Starting on the positive y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y0</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordinate of the center of the circle</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate of the center of the circle</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the circle</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The circumference of the circle in radians. The default of 2*pi gives a full circle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>major, minor)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a path along the outline of an ellipse. The ellipse lies
in the XY plane, and the path starts on the positive x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>major</code></strong> :&ensp;<code>float</code></dt>
<dd>The major axis of the ellipse (lies along the x-axis).</dd>
<dt><strong><code>minor</code></strong> :&ensp;<code>float</code></dt>
<dd>The minor axis of the ellipse (lies along the y-axis).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.from_irregular_function"><code class="name flex">
<span>def <span class="ident">from_irregular_function</span></span>(<span>to_point, N=100, breakpoints=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a path from a function that is of the form u -&gt; point, where 0 &lt;= u &lt;= 1.
The length of the path is determined by integration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>to_point</code></strong> :&ensp;<code>callable</code></dt>
<dd>A function accepting a number in the range [0, 1] and returns a the dimensional point.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to use in the cubic spline interpolation.</dd>
<dt><strong><code>breakpoints</code></strong> :&ensp;<code>float iterable</code></dt>
<dd>Points (0 &lt;= u &lt;= 1) on the path where the function is non-differentiable. These points
are always included in the resulting mesh.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>from_, to)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a straight line between two points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>from_</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The starting point of the path.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The endpoint of the path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.polar_arc"><code class="name flex">
<span>def <span class="ident">polar_arc</span></span>(<span>radius, angle, start, direction, plane_normal=[0, 1, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Return an arc specified by polar coordinates. The arc lies in a plane defined by the
provided normal vector and curves from the start point in the specified direction
counterclockwise around the normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the arc.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle subtended by the arc (in radians)</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The start point of the arc</dd>
<dt><strong><code>plane_normal</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The normal vector of the plane containing the arc</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>A tangent of the arc at the starting point.
Must lie in the specified plane. Does not need to be normalized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.rectangle_xy"><code class="name flex">
<span>def <span class="ident">rectangle_xy</span></span>(<span>xmin, xmax, ymin, ymax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the XY plane. The path starts at (xmin, ymin, 0), and is
counter clockwise around the z-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum x-coordinate of the corner points.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum x-coordinate of the corner points.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum y-coordinate of the corner points.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum y-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.rectangle_xz"><code class="name flex">
<span>def <span class="ident">rectangle_xz</span></span>(<span>xmin, xmax, zmin, zmax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the XZ plane. The path starts at (xmin, 0, zmin), and is
counter clockwise around the y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum x-coordinate of the corner points.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum x-coordinate of the corner points.</dd>
<dt><strong><code>zmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum z-coordinate of the corner points.</dd>
<dt><strong><code>zmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum z-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.rectangle_yz"><code class="name flex">
<span>def <span class="ident">rectangle_yz</span></span>(<span>ymin, ymax, zmin, zmax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the YZ plane. The path starts at (0, ymin, zmin), and is
counter clockwise around the x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ymin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum y-coordinate of the corner points.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum y-coordinate of the corner points.</dd>
<dt><strong><code>zmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum z-coordinate of the corner points.</dd>
<dt><strong><code>zmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum z-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.spline_through_points"><code class="name flex">
<span>def <span class="ident">spline_through_points</span></span>(<span>points, N=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a path by fitting a cubic spline through the given points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>(N, 3) ndarray</code> of <code>float</code></dt>
<dd>Three dimensional points through which the spline is fitted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="traceon.geometry.Path.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Add two paths to create a PathCollection. Note that a PathCollection supports
a subset of the methods of Path (for example, movement, rotation and meshing). Use
the + operator to combine paths into a path collection: path1 + path2 + path3.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.PathCollection" href="#traceon.geometry.PathCollection">PathCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate a point along the path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>The length along the path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(3,) float</p>
<p>Three dimensional point.</p></div>
</dd>
<dt id="traceon.geometry.Path.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine two paths to create a single path. The endpoint of the first path needs
to match the starting point of the second path. This common point is marked as a breakpoint and
always included in the mesh. To use this function use the right shift operator (p1 &gt;&gt; p2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>The second path, to extend the current path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.add_phase"><code class="name flex">
<span>def <span class="ident">add_phase</span></span>(<span>self, l)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a phase to a closed path. A path is closed when the starting point is equal to the
end point. A phase of length l means that the path starts 'further down' the closed path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>The phase (expressed as a path length). The resulting path starts l distance along the
original path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.average"><code class="name flex">
<span>def <span class="ident">average</span></span>(<span>self, fun)</span>
</code></dt>
<dd>
<div class="desc"><p>Average a function along the path, by integrating 1/l * fun(path(l)) with 0 &lt;= l &lt;= path length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fun</code></strong> :&ensp;<code>callable (3,) -&gt; float</code></dt>
<dd>A function taking a three dimensional point and returning a float.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The average value of the function along the point.</p></div>
</dd>
<dt id="traceon.geometry.Path.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the path, by making a straight line to the starting point.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Cut the path in two at a specific length along the path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length along the path at which to cut.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(Path, Path)</p>
<p>A tuple containing two paths. The first path contains the path upto length, while the second path contains the rest.</p></div>
</dd>
<dt id="traceon.geometry.Path.endpoint"><code class="name flex">
<span>def <span class="ident">endpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the endpoint of the path.</p>
<h2 id="returns">Returns</h2>
<p>(3,) float</p>
<p>The endpoint of the path.</p></div>
</dd>
<dt id="traceon.geometry.Path.extend_with_arc"><code class="name flex">
<span>def <span class="ident">extend_with_arc</span></span>(<span>self, center, end, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the current path using an arc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The center point of the arc.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The endpoint of the arc, shoud lie on a circle determined
by the given centerpoint and the current endpoint.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.extend_with_line"><code class="name flex">
<span>def <span class="ident">extend_with_line</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the current path by a line from the current endpoint to the given point.
The given point is marked a breakpoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The new endpoint.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.extend_with_polar_arc"><code class="name flex">
<span>def <span class="ident">extend_with_polar_arc</span></span>(<span>self, radius, angle, plane_normal=[0, 1, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the current path by a smooth arc using polar coordinates.
The arc is defined by a specified radius and angle and rotates counterclockwise
around around the normal that defines the arcing plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the arc</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle subtended by the arc (in radians)</dd>
<dt><strong><code>plane_normal</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The normal vector of the plane containing the arc</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.extrude"><code class="name flex">
<span>def <span class="ident">extrude</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by extruding the path along a vector. The vector gives both
the length and the direction of the extrusion.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The direction and length (norm of the vector) to extrude by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.extrude_by_path"><code class="name flex">
<span>def <span class="ident">extrude_by_path</span></span>(<span>self, p2)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by extruding the path along a second path. The second
path does not need to start along the first path. Imagine the surface created
by moving the first path along the second path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p2</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>The (second) path defining the extrusion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine whether the path is closed, by comparing the starting and endpoint.</p>
<h2 id="returns">Returns</h2>
<p>bool: True if the path is closed, False otherwise.</p></div>
</dd>
<dt id="traceon.geometry.Path.map_points"><code class="name flex">
<span>def <span class="ident">map_points</span></span>(<span>self, fun)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new function by mapping a function over points along the path (see <code><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></code>).
The path length is assumed to stay the same after this operation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fun</code></strong> :&ensp;<code>callable (3,) -&gt; (3,)</code></dt>
<dd>Function taking three dimensional points and returning three dimensional points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Path</p></div>
</dd>
<dt id="traceon.geometry.Path.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, mesh_size=None, mesh_size_factor=None, higher_order=False, name=None, ensure_outward_normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh the path, so it can be used in the BEM solver. The result of meshing a path
are (possibly curved) line elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Determines amount of elements in the mesh. A smaller
mesh size leads to more elements.</dd>
<dt><strong><code>mesh_size_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Alternative way to specify the mesh size, which scales
with the dimensions of the geometry, and therefore more
easily translates between different geometries.</dd>
<dt><strong><code>higher_order</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to generate a higher order mesh. A higher order
produces curved line elements (determined by 4 points on
each curved element). The BEM solver supports higher order
elements in radial symmetric geometries only.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Assign this name to the mesh, instead of the name value assinged to Surface.name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="traceon.mesher.Mesh" href="mesher.html#traceon.mesher.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="traceon.geometry.Path.middle_point"><code class="name flex">
<span>def <span class="ident">middle_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the midpoint of the path (in terms of length along the path.)</p>
<h2 id="returns">Returns</h2>
<p>(3,) float</p>
<p>The point at the middle of the path.</p></div>
</dd>
<dt id="traceon.geometry.Path.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a reversed version of the current path.
The reversed path is created by inverting the traversal direction,
such that the start becomes the end and vice versa.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.revolve_x"><code class="name flex">
<span>def <span class="ident">revolve_x</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by revolving the path anti-clockwise around the x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.revolve_y"><code class="name flex">
<span>def <span class="ident">revolve_y</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by revolving the path anti-clockwise around the y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.revolve_z"><code class="name flex">
<span>def <span class="ident">revolve_z</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by revolving the path anti-clockwise around the z-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Path.starting_point"><code class="name flex">
<span>def <span class="ident">starting_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the starting point of the path.</p>
<h2 id="returns">Returns</h2>
<p>(3,) float</p>
<p>The starting point of the path.</p></div>
</dd>
<dt id="traceon.geometry.Path.velocity_vector"><code class="name flex">
<span>def <span class="ident">velocity_vector</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the velocity (tangent) vector at a specific point on the path
using cubic spline interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>The point on the path at which to calculate the velocity</dd>
<dt><strong><code>num_splines</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of samples used for cubic spline interpolation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(3,) np.ndarray of float</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></b></code>:
<ul class="hlist">
<li><code><a title="traceon.mesher.GeometricObject.mirror_xy" href="mesher.html#traceon.mesher.GeometricObject.mirror_xy">mirror_xy</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xz" href="mesher.html#traceon.mesher.GeometricObject.mirror_xz">mirror_xz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_yz" href="mesher.html#traceon.mesher.GeometricObject.mirror_yz">mirror_yz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.move" href="mesher.html#traceon.mesher.GeometricObject.move">move</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.rotate" href="mesher.html#traceon.mesher.GeometricObject.rotate">rotate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="traceon.geometry.PathCollection"><code class="flex name class">
<span>class <span class="ident">PathCollection</span></span>
<span>(</span><span>paths)</span>
</code></dt>
<dd>
<div class="desc"><p>A PathCollection is a collection of <code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code>. It can be created using the + operator (for example path1+path2).
Note that <code><a title="traceon.geometry.PathCollection" href="#traceon.geometry.PathCollection">PathCollection</a></code> is a subclass of <code><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></code>, and therefore can be easily moved and rotated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathCollection(GeometricObject):
    &#34;&#34;&#34;A PathCollection is a collection of `Path`. It can be created using the + operator (for example path1+path2).
    Note that `PathCollection` is a subclass of `traceon.mesher.GeometricObject`, and therefore can be easily moved and rotated.&#34;&#34;&#34;
    
    def __init__(self, paths):
        assert all([isinstance(p, Path) for p in paths])
        self.paths = paths
        self._name = None
    
    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name
         
        for path in self.paths:
            path.name = name
     
    def map_points(self, fun):
        return PathCollection([p.map_points(fun) for p in self.paths])
     
    def mesh(self, mesh_size=None, mesh_size_factor=None, higher_order=False, name=None, ensure_outward_normals=True):
        &#34;&#34;&#34;See `Path.mesh`&#34;&#34;&#34;
        mesh = Mesh()
        
        name = self.name if name is None else name
        
        for p in self.paths:
            mesh = mesh + p.mesh(mesh_size=mesh_size, mesh_size_factor=mesh_size_factor,
                                higher_order=higher_order, name=name, ensure_outward_normals=ensure_outward_normals)

        return mesh

    def _map_to_surfaces(self, f, *args, **kwargs):
        surfaces = []

        for p in self.paths:
            surfaces.append(f(p, *args, **kwargs))

        return SurfaceCollection(surfaces)
    
    def __add__(self, other):
        &#34;&#34;&#34;Allows you to combine paths and path collection using the + operator (path1 + path2).&#34;&#34;&#34;
        if isinstance(other, Path):
            return PathCollection(self.paths+[other])
        
        if isinstance(other, PathCollection):
            return PathCollection(self.paths+other.paths)

        return NotImplemented
      
    def __iadd__(self, other):
        &#34;&#34;&#34;Allows you to add paths to the collection using the += operator.&#34;&#34;&#34;
        assert isinstance(other, PathCollection) or isinstance(other, Path)

        if isinstance(other, Path):
            self.paths.append(other)
        else:
            self.paths.extend(other.paths)
       
    def revolve_x(self, angle=2*pi):
        return self._map_to_surfaces(Path.revolve_x, angle=angle)
    def revolve_y(self, angle=2*pi):
        return self._map_to_surfaces(Path.revolve_y, angle=angle)
    def revolve_z(self, angle=2*pi):
        return self._map_to_surfaces(Path.revolve_z, angle=angle)
    def extrude(self, vector):
        return self._map_to_surfaces(Path.extrude, vector)
    def extrude_by_path(self, p2):
        return self._map_to_surfaces(Path.extrude_by_path, p2)
    
    def __str__(self):
        return f&#34;&lt;PathCollection with {len(self.paths)} surfaces, name: {self.name}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="traceon.geometry.PathCollection.name"><code class="name">prop <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="traceon.geometry.PathCollection.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to combine paths and path collection using the + operator (path1 + path2).</p></div>
</dd>
<dt id="traceon.geometry.PathCollection.__iadd__"><code class="name flex">
<span>def <span class="ident">__iadd__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to add paths to the collection using the += operator.</p></div>
</dd>
<dt id="traceon.geometry.PathCollection.extrude"><code class="name flex">
<span>def <span class="ident">extrude</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.geometry.PathCollection.extrude_by_path"><code class="name flex">
<span>def <span class="ident">extrude_by_path</span></span>(<span>self, p2)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.geometry.PathCollection.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, mesh_size=None, mesh_size_factor=None, higher_order=False, name=None, ensure_outward_normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="traceon.geometry.Path.mesh" href="#traceon.geometry.Path.mesh">Path.mesh()</a></code></p></div>
</dd>
<dt id="traceon.geometry.PathCollection.revolve_x"><code class="name flex">
<span>def <span class="ident">revolve_x</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.geometry.PathCollection.revolve_y"><code class="name flex">
<span>def <span class="ident">revolve_y</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.geometry.PathCollection.revolve_z"><code class="name flex">
<span>def <span class="ident">revolve_z</span></span>(<span>self, angle=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></b></code>:
<ul class="hlist">
<li><code><a title="traceon.mesher.GeometricObject.map_points" href="mesher.html#traceon.mesher.GeometricObject.map_points">map_points</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xy" href="mesher.html#traceon.mesher.GeometricObject.mirror_xy">mirror_xy</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xz" href="mesher.html#traceon.mesher.GeometricObject.mirror_xz">mirror_xz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_yz" href="mesher.html#traceon.mesher.GeometricObject.mirror_yz">mirror_yz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.move" href="mesher.html#traceon.mesher.GeometricObject.move">move</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.rotate" href="mesher.html#traceon.mesher.GeometricObject.rotate">rotate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="traceon.geometry.Surface"><code class="flex name class">
<span>class <span class="ident">Surface</span></span>
<span>(</span><span>fun, path_length1, path_length2, breakpoints1=[], breakpoints2=[], name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Surface is a mapping from two numbers to a three dimensional point.
Note that <code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code> is a subclass of <code><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></code>, and therefore can be easily moved and rotated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Surface(GeometricObject):
    &#34;&#34;&#34;A Surface is a mapping from two numbers to a three dimensional point.
    Note that `Surface` is a subclass of `traceon.mesher.GeometricObject`, and therefore can be easily moved and rotated.&#34;&#34;&#34;

    def __init__(self, fun, path_length1, path_length2, breakpoints1=[], breakpoints2=[], name=None):
        self.fun = fun
        self.path_length1 = path_length1
        self.path_length2 = path_length2
        self.breakpoints1 = breakpoints1
        self.breakpoints2 = breakpoints2
        self.name = name

    def _sections(self): 
        b1 = [0.] + self.breakpoints1 + [self.path_length1]
        b2 = [0.] + self.breakpoints2 + [self.path_length2]

        for u0, u1 in zip(b1[:-1], b1[1:]):
            for v0, v1 in zip(b2[:-1], b2[1:]):
                def fun(u, v, u0_=u0, v0_=v0):
                    return self(u0_+u, v0_+v)
                yield Surface(fun, u1-u0, v1-v0, [], [])
       
    def __call__(self, u, v):
        &#34;&#34;&#34;Evaluate the surface at point (u, v). Returns a three dimensional point.

        Parameters
        ------------------------------
        u: float
            First coordinate, should be 0 &lt;= u &lt;= self.path_length1
        v: float
            Second coordinate, should be 0 &lt;= v &lt;= self.path_length2

        Returns
        ----------------------------
        (3,) np.ndarray of double&#34;&#34;&#34;
        return self.fun(u, v)

    def map_points(self, fun):
        return Surface(lambda u, v: fun(self(u, v)),
            self.path_length1, self.path_length2,
            self.breakpoints1, self.breakpoints2, name=self.name)
    
    @staticmethod
    def spanned_by_paths(path1, path2):
        &#34;&#34;&#34;Create a surface by considering the area between two paths. Imagine two points
        progressing along the path simultaneously and at each step drawing a straight line
        between the points.

        Parameters
        --------------------------
        path1: Path
            The path characterizing one edge of the surface
        path2: Path
            The path characterizing the opposite edge of the surface

        Returns
        --------------------------
        Surface&#34;&#34;&#34;
        length1 = max(path1.path_length, path2.path_length)
        
        length_start = np.linalg.norm(path1.starting_point() - path2.starting_point())
        length_final = np.linalg.norm(path1.endpoint() - path2.endpoint())
        length2 = (length_start + length_final)/2
         
        def f(u, v):
            p1 = path1(u/length1*path1.path_length) # u/l*p = b, u = l*b/p
            p2 = path2(u/length1*path2.path_length)
            return (1-v/length2)*p1 + v/length2*p2

        breakpoints = sorted([length1*b/path1.path_length for b in path1.breakpoints] + \
                                [length1*b/path2.path_length for b in path2.breakpoints])
         
        return Surface(f, length1, length2, breakpoints)

    @staticmethod
    def sphere(radius):
        &#34;&#34;&#34;Create a sphere with the given radius, the center of the sphere is
        at the origin, but can easily be moved by using the `mesher.GeometricObject.move` method.

        Parameters
        ------------------------------
        radius: float
            The radius of the sphere

        Returns
        -----------------------------
        Surface representing the sphere&#34;&#34;&#34;
        
        length1 = 2*pi*radius
        length2 = pi*radius
         
        def f(u, v):
            phi = u/radius
            theta = v/radius
            
            return np.array([
                radius*sin(theta)*cos(phi),
                radius*sin(theta)*sin(phi),
                radius*cos(theta)]) 
        
        return Surface(f, length1, length2)

    @staticmethod
    def box(p0, p1):
        &#34;&#34;&#34;Create a box with the two given points at opposite corners.

        Parameters
        -------------------------------
        p0: (3,) np.ndarray double
            One corner of the box
        p1: (3,) np.ndarray double
            The opposite corner of the box

        Returns
        -------------------------------
        Surface representing the box&#34;&#34;&#34;

        x0, y0, z0 = p0
        x1, y1, z1 = p1

        xmin, ymin, zmin = min(x0, x1), min(y0, y1), min(z0, z1)
        xmax, ymax, zmax = max(x0, x1), max(y0, y1), max(z0, z1)
        
        path1 = Path.line([xmin, ymin, zmax], [xmax, ymin, zmax])
        path2 = Path.line([xmin, ymin, zmin], [xmax, ymin, zmin])
        path3 = Path.line([xmin, ymax, zmax], [xmax, ymax, zmax])
        path4 = Path.line([xmin, ymax, zmin], [xmax, ymax, zmin])
        
        side_path = Path.line([xmin, ymin, zmin], [xmax, ymin, zmin])\
            .extend_with_line([xmax, ymin, zmax])\
            .extend_with_line([xmin, ymin, zmax])\
            .close()

        side_surface = side_path.extrude([0.0, ymax-ymin, 0.0])
        top = Surface.spanned_by_paths(path1, path2)
        bottom = Surface.spanned_by_paths(path4, path3)
         
        return (top + bottom + side_surface)

    @staticmethod
    def from_boundary_paths(p1, p2, p3, p4):
        &#34;&#34;&#34;Create a surface with the four given paths as the boundary.

        Parameters
        ----------------------------------
        p1: Path
            First edge of the surface
        p2: Path
            Second edge of the surface
        p3: Path
            Third edge of the surface
        p4: Path
            Fourth edge of the surface

        Returns
        ------------------------------------
        Surface with the four giving paths as the boundary
        &#34;&#34;&#34;
        path_length_p1_and_p3 = (p1.path_length + p3.path_length)/2
        path_length_p2_and_p4 = (p2.path_length + p4.path_length)/2

        def f(u, v):
            u /= path_length_p1_and_p3
            v /= path_length_p2_and_p4
            
            a = (1-v)
            b = (1-u)
             
            c = v
            d = u
            
            return 1/2*(a*p1(u*p1.path_length) + \
                        b*p4((1-v)*p4.path_length) + \
                        c*p3((1-u)*p3.path_length) + \
                        d*p2(v*p2.path_length))
        
        # Scale the breakpoints appropriately
        b1 = sorted([b/p1.path_length * path_length_p1_and_p3 for b in p1.breakpoints] + \
                [b/p3.path_length * path_length_p1_and_p3 for b in p3.breakpoints])
        b2 = sorted([b/p2.path_length * path_length_p2_and_p4 for b in p2.breakpoints] + \
                [b/p4.path_length * path_length_p2_and_p4 for b in p4.breakpoints])
        
        return Surface(f, path_length_p1_and_p3, path_length_p2_and_p4, b1, b2)
     
    @staticmethod
    def disk_xz(x0, z0, radius):
        &#34;&#34;&#34;Create a disk in the XZ plane.         
        
        Parameters
        ------------------------
        x0: float
            x-coordiante of the center of the disk
        z0: float
            z-coordinate of the center of the disk
        radius: float
            radius of the disk
        Returns
        -----------------------
        Surface&#34;&#34;&#34;
        assert radius &gt; 0, &#34;radius must be a positive number&#34;
        disk_at_origin = Path.line([0.0, 0.0, 0.0], [radius, 0.0, 0.0]).revolve_y()
        return disk_at_origin.move(dx=x0, dz=z0)
    
    @staticmethod
    def disk_yz(y0, z0, radius):
        &#34;&#34;&#34;Create a disk in the YZ plane.         
        
        Parameters
        ------------------------
        y0: float
            y-coordiante of the center of the disk
        z0: float
            z-coordinate of the center of the disk
        radius: float
            radius of the disk
        Returns
        -----------------------
        Surface&#34;&#34;&#34;
        assert radius &gt; 0, &#34;radius must be a positive number&#34;
        disk_at_origin = Path.line([0.0, 0.0, 0.0], [0.0, radius, 0.0]).revolve_x()
        return disk_at_origin.move(dy=y0, dz=z0)

    @staticmethod
    def disk_xy(x0, y0, radius):
        &#34;&#34;&#34;Create a disk in the XY plane.
        
        Parameters
        ------------------------
        x0: float
            x-coordiante of the center of the disk
        y0: float
            y-coordinate of the center of the disk
        radius: float
            radius of the disk
        Returns
        -----------------------
        Surface&#34;&#34;&#34;
        assert radius &gt; 0, &#34;radius must be a positive number&#34;
        disk_at_origin = Path.line([0.0, 0.0, 0.0], [radius, 0.0, 0.0]).revolve_z()
        return disk_at_origin.move(dx=x0, dy=y0)
     
    @staticmethod
    def rectangle_xz(xmin, xmax, zmin, zmax):
        &#34;&#34;&#34;Create a rectangle in the XZ plane. The path starts at (xmin, 0, zmin), and is 
        counter clockwise around the y-axis.
        
        Parameters
        ------------------------
        xmin: float
            Minimum x-coordinate of the corner points.
        xmax: float
            Maximum x-coordinate of the corner points.
        zmin: float
            Minimum z-coordinate of the corner points.
        zmax: float
            Maximum z-coordinate of the corner points.
        
        Returns
        -----------------------
        Surface representing the rectangle&#34;&#34;&#34;
        return Path.line([xmin, 0., zmin], [xmin, 0, zmax]).extrude([xmax-xmin, 0., 0.])
     
    @staticmethod
    def rectangle_yz(ymin, ymax, zmin, zmax):
        &#34;&#34;&#34;Create a rectangle in the YZ plane. The path starts at (0, ymin, zmin), and is 
        counter clockwise around the x-axis.
        
        Parameters
        ------------------------
        ymin: float
            Minimum y-coordinate of the corner points.
        ymax: float
            Maximum y-coordinate of the corner points.
        zmin: float
            Minimum z-coordinate of the corner points.
        zmax: float
            Maximum z-coordinate of the corner points.
        
        Returns
        -----------------------
        Surface representing the rectangle&#34;&#34;&#34;
        return Path.line([0., ymin, zmin], [0., ymin, zmax]).extrude([0., ymax-ymin, 0.])
     
    @staticmethod
    def rectangle_xy(xmin, xmax, ymin, ymax):
        &#34;&#34;&#34;Create a rectangle in the XY plane. The path starts at (xmin, ymin, 0), and is 
        counter clockwise around the z-axis.
        
        Parameters
        ------------------------
        xmin: float
            Minimum x-coordinate of the corner points.
        xmax: float
            Maximum x-coordinate of the corner points.
        ymin: float
            Minimum y-coordinate of the corner points.
        ymax: float
            Maximum y-coordinate of the corner points.
        
        Returns
        -----------------------
        Surface representing the rectangle&#34;&#34;&#34;
        return Path.line([xmin, ymin, 0.], [xmin, ymax, 0.]).extrude([xmax-xmin, 0., 0.])

    @staticmethod
    def aperture(height, radius, extent, z=0.):
        return Path.aperture(height, radius, extent, z=z).revolve_z()
    
    def get_boundary_paths(self):
        &#34;&#34;&#34;Get the boundary paths of the surface.
        Computes the boundary paths (edges) of the surface and combines them into a `PathCollection`.
        Non-closed paths get filtered out when closed paths are present, as only closed paths 
        represent true boundaries in this case.
        Note that this function might behave unexpectedly for surfaces without any boundaries (e.g a sphere).

        Returns
        ----------------------------
        PathCollection representing the boundary paths of the surface&#34;&#34;&#34;
        
        b1 = Path(lambda u: self(u, 0.), self.path_length1, self.breakpoints1, self.name)
        b2 = Path(lambda u: self(u, self.path_length2), self.path_length1, self.breakpoints1, self.name)
        b3 = Path(lambda v: self(0., v), self.path_length2, self.breakpoints2, self.name)
        b4 = Path(lambda v: self(self.path_length1, v), self.path_length2, self.breakpoints2, self.name)
        
        boundary = b1 + b2 + b3 + b4

        if any([b.is_closed() for b in boundary.paths]):
            boundary = PathCollection([b for b in boundary.paths if b.is_closed()])
        
        return boundary

    def extrude_boundary(self, vector, enclose=True):
        &#34;&#34;&#34;
        Extrude the boundary paths of the surface along a vector. The vector gives both
        the length and the direction of the extrusion.

        Parameters
        -------------------------
        vector: (3,) float
            The direction and length (norm of the vector) to extrude by.
        enclose: bool
            Whether enclose the extrusion by adding a copy of the original surface 
            moved by the extrusion vector to the resulting SurfaceCollection.

        Returns
        -------------------------
        SurfaceCollection&#34;&#34;&#34;

        boundary = self.get_boundary_paths()
        extruded_boundary = boundary.extrude(vector)

        if enclose:
            return self + extruded_boundary + self.move(*vector) 
        else:
            return self + extruded_boundary
    
    def extrude_boundary_by_path(self, path, enclose=True):
        &#34;&#34;&#34;Extrude the boundary paths of a surface along a path. The path 
        does not need to start at the surface. Imagine the  extrusion surface 
        created by moving the boundary paths along the path.

        Parameters
        -------------------------
        path: Path
            The path defining the extrusion.
        enclose: bool
            Whether to enclose the extrusion by adding a copy of the original surface 
            moved by the extrusion vector to the resulting SurfaceCollection.
            
        Returns
        ------------------------
        SurfaceCollection&#34;&#34;&#34;
        
        boundary = self.get_boundary_paths()
        extruded_boundary = boundary.extrude(path)

        if enclose:
            path_vector = path.endpoint() - path.starting_point()
            return self + extruded_boundary + self.move(*path_vector) 
        else:
            return self + extruded_boundary
    
    def revolve_boundary_x(self, angle=2*pi, enclose=True):
        &#34;&#34;&#34;Revolve the boundary paths of the surface anti-clockwise around the x-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.
        enclose: bool
            Whether enclose the revolution by adding a copy of the original surface 
            rotated over the angle to the resulting SurfaceCollection.

        Returns
        -----------------------
        SurfaceCollection&#34;&#34;&#34;

        boundary = self.get_boundary_paths()
        revolved_boundary = boundary.revolve_x(angle)

        if enclose and not np.isclose(angle, 2*pi, atol=1e-8):
            return self + revolved_boundary + self.rotate(Rx=angle)
        else:
            return self + revolved_boundary
        
    def revolve_boundary_y(self, angle=2*pi, enclose=True):
        &#34;&#34;&#34;Revolve the boundary paths of the surface anti-clockwise around the y-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.
        cap_extension: bool
            Whether to enclose the revolution by adding a copy of the original surface 
            rotated over the angle to the resulting SurfaceCollection.

        Returns
        -----------------------
        SurfaceCollection&#34;&#34;&#34;

        boundary = self.get_boundary_paths()
        revolved_boundary = boundary.revolve_y(angle)

        if enclose and not np.isclose(angle, 2*pi, atol=1e-8):
            return self + revolved_boundary + self.rotate(Ry=angle)
        else:
            return self + revolved_boundary
    
    def revolve_boundary_z(self, angle=2*pi, enclose=True):
        &#34;&#34;&#34;Revolve the boundary paths of the surface anti-clockwise around the z-axis.
        
        Parameters
        -----------------------
        angle: float
            The angle by which to revolve. THe default 2*pi gives a full revolution.
        cap_extension: bool
            Whether to enclose the revolution by adding a copy of the original surface 
            rotated over the angle to the resulting SurfaceCollection.

        Returns
        -----------------------
        SurfaceCollection&#34;&#34;&#34;

        boundary = self.get_boundary_paths()
        revolved_boundary = boundary.revolve_z(angle)
        
        if enclose and not np.isclose(angle, 2*pi, atol=1e-8):
            return self + revolved_boundary + self.rotate(Rz=angle)
        else:
            return self + revolved_boundary

    def __add__(self, other):
        &#34;&#34;&#34;Allows you to combine surfaces into a `SurfaceCollection` using the + operator (surface1 + surface2).&#34;&#34;&#34;
        if isinstance(other, Surface):
            return SurfaceCollection([self, other])
        
        if isinstance(other, SurfaceCollection):
            return SurfaceCollection([self] + other.surfaces)

        return NotImplemented
     
    def mesh(self, mesh_size=None, mesh_size_factor=None, name=None, ensure_outward_normals=True):
        &#34;&#34;&#34;Mesh the surface, so it can be used in the BEM solver. The result of meshing
        a surface are triangles.

        Parameters
        --------------------------
        mesh_size: float
            Determines amount of elements in the mesh. A smaller
            mesh size leads to more elements.
        mesh_size_factor: float
            Alternative way to specify the mesh size, which scales
            with the dimensions of the geometry, and therefore more
            easily translates between different geometries.
        name: str
            Assign this name to the mesh, instead of the name value assinged to Surface.name
        
        Returns
        ----------------------------
        `traceon.mesher.Mesh`&#34;&#34;&#34;
         
        if mesh_size is None:
            path_length = min(self.path_length1, self.path_length2)
             
            mesh_size = path_length / 4

            if mesh_size_factor is not None:
                mesh_size /= sqrt(mesh_size_factor)

        name = self.name if name is None else name
        return _mesh(self, mesh_size, name=name, ensure_outward_normals=ensure_outward_normals)
    
    def __str__(self):
        return f&#34;&lt;Surface with name: {self.name}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="traceon.geometry.Surface.aperture"><code class="name flex">
<span>def <span class="ident">aperture</span></span>(<span>height, radius, extent, z=0.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.geometry.Surface.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>p0, p1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a box with the two given points at opposite corners.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p0</code></strong> :&ensp;<code>(3,) np.ndarray double</code></dt>
<dd>One corner of the box</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code>(3,) np.ndarray double</code></dt>
<dd>The opposite corner of the box</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> representing the box</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.disk_xy"><code class="name flex">
<span>def <span class="ident">disk_xy</span></span>(<span>x0, y0, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a disk in the XY plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordiante of the center of the disk</dd>
<dt><strong><code>y0</code></strong> :&ensp;<code>float</code></dt>
<dd>y-coordinate of the center of the disk</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the disk</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.disk_xz"><code class="name flex">
<span>def <span class="ident">disk_xz</span></span>(<span>x0, z0, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a disk in the XZ plane.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordiante of the center of the disk</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate of the center of the disk</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the disk</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.disk_yz"><code class="name flex">
<span>def <span class="ident">disk_yz</span></span>(<span>y0, z0, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a disk in the YZ plane.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y0</code></strong> :&ensp;<code>float</code></dt>
<dd>y-coordiante of the center of the disk</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>z-coordinate of the center of the disk</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the disk</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.from_boundary_paths"><code class="name flex">
<span>def <span class="ident">from_boundary_paths</span></span>(<span>p1, p2, p3, p4)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface with the four given paths as the boundary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p1</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>First edge of the surface</dd>
<dt><strong><code>p2</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>Second edge of the surface</dd>
<dt><strong><code>p3</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>Third edge of the surface</dd>
<dt><strong><code>p4</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>Fourth edge of the surface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> with the four giving paths as the boundary</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.rectangle_xy"><code class="name flex">
<span>def <span class="ident">rectangle_xy</span></span>(<span>xmin, xmax, ymin, ymax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the XY plane. The path starts at (xmin, ymin, 0), and is
counter clockwise around the z-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum x-coordinate of the corner points.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum x-coordinate of the corner points.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum y-coordinate of the corner points.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum y-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> representing the rectangle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.rectangle_xz"><code class="name flex">
<span>def <span class="ident">rectangle_xz</span></span>(<span>xmin, xmax, zmin, zmax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the XZ plane. The path starts at (xmin, 0, zmin), and is
counter clockwise around the y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum x-coordinate of the corner points.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum x-coordinate of the corner points.</dd>
<dt><strong><code>zmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum z-coordinate of the corner points.</dd>
<dt><strong><code>zmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum z-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> representing the rectangle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.rectangle_yz"><code class="name flex">
<span>def <span class="ident">rectangle_yz</span></span>(<span>ymin, ymax, zmin, zmax)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rectangle in the YZ plane. The path starts at (0, ymin, zmin), and is
counter clockwise around the x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ymin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum y-coordinate of the corner points.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum y-coordinate of the corner points.</dd>
<dt><strong><code>zmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum z-coordinate of the corner points.</dd>
<dt><strong><code>zmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum z-coordinate of the corner points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> representing the rectangle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.spanned_by_paths"><code class="name flex">
<span>def <span class="ident">spanned_by_paths</span></span>(<span>path1, path2)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a surface by considering the area between two paths. Imagine two points
progressing along the path simultaneously and at each step drawing a straight line
between the points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path1</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>The path characterizing one edge of the surface</dd>
<dt><strong><code>path2</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>The path characterizing the opposite edge of the surface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a sphere with the given radius, the center of the sphere is
at the origin, but can easily be moved by using the <code>mesher.GeometricObject.move</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the sphere</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a> representing the sphere</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="traceon.geometry.Surface.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to combine surfaces into a <code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code> using the + operator (surface1 + surface2).</p></div>
</dd>
<dt id="traceon.geometry.Surface.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the surface at point (u, v). Returns a three dimensional point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>First coordinate, should be 0 &lt;= u &lt;= self.path_length1</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>Second coordinate, should be 0 &lt;= v &lt;= self.path_length2</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(3,) np.ndarray of double</p></div>
</dd>
<dt id="traceon.geometry.Surface.extrude_boundary"><code class="name flex">
<span>def <span class="ident">extrude_boundary</span></span>(<span>self, vector, enclose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Extrude the boundary paths of the surface along a vector. The vector gives both
the length and the direction of the extrusion.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The direction and length (norm of the vector) to extrude by.</dd>
<dt><strong><code>enclose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether enclose the extrusion by adding a copy of the original surface
moved by the extrusion vector to the resulting SurfaceCollection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.extrude_boundary_by_path"><code class="name flex">
<span>def <span class="ident">extrude_boundary_by_path</span></span>(<span>self, path, enclose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Extrude the boundary paths of a surface along a path. The path
does not need to start at the surface. Imagine the
extrusion surface
created by moving the boundary paths along the path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></dt>
<dd>The path defining the extrusion.</dd>
<dt><strong><code>enclose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to enclose the extrusion by adding a copy of the original surface
moved by the extrusion vector to the resulting SurfaceCollection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.get_boundary_paths"><code class="name flex">
<span>def <span class="ident">get_boundary_paths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the boundary paths of the surface.
Computes the boundary paths (edges) of the surface and combines them into a <code><a title="traceon.geometry.PathCollection" href="#traceon.geometry.PathCollection">PathCollection</a></code>.
Non-closed paths get filtered out when closed paths are present, as only closed paths
represent true boundaries in this case.
Note that this function might behave unexpectedly for surfaces without any boundaries (e.g a sphere).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.PathCollection" href="#traceon.geometry.PathCollection">PathCollection</a> representing the boundary paths</code> of <code>the surface</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, mesh_size=None, mesh_size_factor=None, name=None, ensure_outward_normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh the surface, so it can be used in the BEM solver. The result of meshing
a surface are triangles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Determines amount of elements in the mesh. A smaller
mesh size leads to more elements.</dd>
<dt><strong><code>mesh_size_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Alternative way to specify the mesh size, which scales
with the dimensions of the geometry, and therefore more
easily translates between different geometries.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Assign this name to the mesh, instead of the name value assinged to Surface.name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="traceon.mesher.Mesh" href="mesher.html#traceon.mesher.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="traceon.geometry.Surface.revolve_boundary_x"><code class="name flex">
<span>def <span class="ident">revolve_boundary_x</span></span>(<span>self, angle=6.283185307179586, enclose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Revolve the boundary paths of the surface anti-clockwise around the x-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
<dt><strong><code>enclose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether enclose the revolution by adding a copy of the original surface
rotated over the angle to the resulting SurfaceCollection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.revolve_boundary_y"><code class="name flex">
<span>def <span class="ident">revolve_boundary_y</span></span>(<span>self, angle=6.283185307179586, enclose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Revolve the boundary paths of the surface anti-clockwise around the y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
<dt><strong><code>cap_extension</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to enclose the revolution by adding a copy of the original surface
rotated over the angle to the resulting SurfaceCollection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="traceon.geometry.Surface.revolve_boundary_z"><code class="name flex">
<span>def <span class="ident">revolve_boundary_z</span></span>(<span>self, angle=6.283185307179586, enclose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Revolve the boundary paths of the surface anti-clockwise around the z-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle by which to revolve. THe default 2*pi gives a full revolution.</dd>
<dt><strong><code>cap_extension</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to enclose the revolution by adding a copy of the original surface
rotated over the angle to the resulting SurfaceCollection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></b></code>:
<ul class="hlist">
<li><code><a title="traceon.mesher.GeometricObject.map_points" href="mesher.html#traceon.mesher.GeometricObject.map_points">map_points</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xy" href="mesher.html#traceon.mesher.GeometricObject.mirror_xy">mirror_xy</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xz" href="mesher.html#traceon.mesher.GeometricObject.mirror_xz">mirror_xz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_yz" href="mesher.html#traceon.mesher.GeometricObject.mirror_yz">mirror_yz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.move" href="mesher.html#traceon.mesher.GeometricObject.move">move</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.rotate" href="mesher.html#traceon.mesher.GeometricObject.rotate">rotate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="traceon.geometry.SurfaceCollection"><code class="flex name class">
<span>class <span class="ident">SurfaceCollection</span></span>
<span>(</span><span>surfaces)</span>
</code></dt>
<dd>
<div class="desc"><p>A SurfaceCollection is a collection of <code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code>. It can be created using the + operator (for example surface1+surface2).
Note that <code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code> is a subclass of <code><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></code>, and therefore can be easily moved and rotated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceCollection(GeometricObject):
    &#34;&#34;&#34;A SurfaceCollection is a collection of `Surface`. It can be created using the + operator (for example surface1+surface2).
    Note that `SurfaceCollection` is a subclass of `traceon.mesher.GeometricObject`, and therefore can be easily moved and rotated.&#34;&#34;&#34;
     
    def __init__(self, surfaces):
        assert all([isinstance(s, Surface) for s in surfaces])
        self.surfaces = surfaces
        self._name = None

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name
         
        for surf in self.surfaces:
            surf.name = name
     
    def map_points(self, fun):
        return SurfaceCollection([s.map_points(fun) for s in self.surfaces])
     
    def mesh(self, mesh_size=None, mesh_size_factor=None, name=None, ensure_outward_normals=True):
        &#34;&#34;&#34;See `Surface.mesh`&#34;&#34;&#34;
        mesh = Mesh()
        
        name = self.name if name is None else name
        
        for s in self.surfaces:
            mesh = mesh + s.mesh(mesh_size=mesh_size, mesh_size_factor=mesh_size_factor, name=name, ensure_outward_normals=ensure_outward_normals)
         
        return mesh
     
    def __add__(self, other):
        &#34;&#34;&#34;Allows you to combine surfaces into a `SurfaceCollection` using the + operator (surface1 + surface2).&#34;&#34;&#34;
        if isinstance(other, Surface):
            return SurfaceCollection(self.surfaces+[other])

        if isinstance(other, SurfaceCollection):
            return SurfaceCollection(self.surfaces+other.surfaces)

        return NotImplemented
     
    def __iadd__(self, other):
        &#34;&#34;&#34;Allows you to add surfaces to the collection using the += operator.&#34;&#34;&#34;
        assert isinstance(other, SurfaceCollection) or isinstance(other, Surface)
        
        if isinstance(other, Surface):
            self.surfaces.append(other)
        else:
            self.surfaces.extend(other.surfaces)

    def __str__(self):
        return f&#34;&lt;SurfaceCollection with {len(self.surfaces)} surfaces, name: {self.name}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="traceon.geometry.SurfaceCollection.name"><code class="name">prop <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="traceon.geometry.SurfaceCollection.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to combine surfaces into a <code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code> using the + operator (surface1 + surface2).</p></div>
</dd>
<dt id="traceon.geometry.SurfaceCollection.__iadd__"><code class="name flex">
<span>def <span class="ident">__iadd__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to add surfaces to the collection using the += operator.</p></div>
</dd>
<dt id="traceon.geometry.SurfaceCollection.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, mesh_size=None, mesh_size_factor=None, name=None, ensure_outward_normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="traceon.geometry.Surface.mesh" href="#traceon.geometry.Surface.mesh">Surface.mesh()</a></code></p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="traceon.mesher.GeometricObject" href="mesher.html#traceon.mesher.GeometricObject">GeometricObject</a></b></code>:
<ul class="hlist">
<li><code><a title="traceon.mesher.GeometricObject.map_points" href="mesher.html#traceon.mesher.GeometricObject.map_points">map_points</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xy" href="mesher.html#traceon.mesher.GeometricObject.mirror_xy">mirror_xy</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_xz" href="mesher.html#traceon.mesher.GeometricObject.mirror_xz">mirror_xz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.mirror_yz" href="mesher.html#traceon.mesher.GeometricObject.mirror_yz">mirror_yz</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.move" href="mesher.html#traceon.mesher.GeometricObject.move">move</a></code></li>
<li><code><a title="traceon.mesher.GeometricObject.rotate" href="mesher.html#traceon.mesher.GeometricObject.rotate">rotate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="traceon" href="index.html">traceon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="traceon.geometry.Path" href="#traceon.geometry.Path">Path</a></code></h4>
<ul class="">
<li><code><a title="traceon.geometry.Path.__add__" href="#traceon.geometry.Path.__add__">__add__</a></code></li>
<li><code><a title="traceon.geometry.Path.__call__" href="#traceon.geometry.Path.__call__">__call__</a></code></li>
<li><code><a title="traceon.geometry.Path.__rshift__" href="#traceon.geometry.Path.__rshift__">__rshift__</a></code></li>
<li><code><a title="traceon.geometry.Path.add_phase" href="#traceon.geometry.Path.add_phase">add_phase</a></code></li>
<li><code><a title="traceon.geometry.Path.aperture" href="#traceon.geometry.Path.aperture">aperture</a></code></li>
<li><code><a title="traceon.geometry.Path.arc" href="#traceon.geometry.Path.arc">arc</a></code></li>
<li><code><a title="traceon.geometry.Path.average" href="#traceon.geometry.Path.average">average</a></code></li>
<li><code><a title="traceon.geometry.Path.circle_xy" href="#traceon.geometry.Path.circle_xy">circle_xy</a></code></li>
<li><code><a title="traceon.geometry.Path.circle_xz" href="#traceon.geometry.Path.circle_xz">circle_xz</a></code></li>
<li><code><a title="traceon.geometry.Path.circle_yz" href="#traceon.geometry.Path.circle_yz">circle_yz</a></code></li>
<li><code><a title="traceon.geometry.Path.close" href="#traceon.geometry.Path.close">close</a></code></li>
<li><code><a title="traceon.geometry.Path.cut" href="#traceon.geometry.Path.cut">cut</a></code></li>
<li><code><a title="traceon.geometry.Path.ellipse" href="#traceon.geometry.Path.ellipse">ellipse</a></code></li>
<li><code><a title="traceon.geometry.Path.endpoint" href="#traceon.geometry.Path.endpoint">endpoint</a></code></li>
<li><code><a title="traceon.geometry.Path.extend_with_arc" href="#traceon.geometry.Path.extend_with_arc">extend_with_arc</a></code></li>
<li><code><a title="traceon.geometry.Path.extend_with_line" href="#traceon.geometry.Path.extend_with_line">extend_with_line</a></code></li>
<li><code><a title="traceon.geometry.Path.extend_with_polar_arc" href="#traceon.geometry.Path.extend_with_polar_arc">extend_with_polar_arc</a></code></li>
<li><code><a title="traceon.geometry.Path.extrude" href="#traceon.geometry.Path.extrude">extrude</a></code></li>
<li><code><a title="traceon.geometry.Path.extrude_by_path" href="#traceon.geometry.Path.extrude_by_path">extrude_by_path</a></code></li>
<li><code><a title="traceon.geometry.Path.from_irregular_function" href="#traceon.geometry.Path.from_irregular_function">from_irregular_function</a></code></li>
<li><code><a title="traceon.geometry.Path.is_closed" href="#traceon.geometry.Path.is_closed">is_closed</a></code></li>
<li><code><a title="traceon.geometry.Path.line" href="#traceon.geometry.Path.line">line</a></code></li>
<li><code><a title="traceon.geometry.Path.map_points" href="#traceon.geometry.Path.map_points">map_points</a></code></li>
<li><code><a title="traceon.geometry.Path.mesh" href="#traceon.geometry.Path.mesh">mesh</a></code></li>
<li><code><a title="traceon.geometry.Path.middle_point" href="#traceon.geometry.Path.middle_point">middle_point</a></code></li>
<li><code><a title="traceon.geometry.Path.polar_arc" href="#traceon.geometry.Path.polar_arc">polar_arc</a></code></li>
<li><code><a title="traceon.geometry.Path.rectangle_xy" href="#traceon.geometry.Path.rectangle_xy">rectangle_xy</a></code></li>
<li><code><a title="traceon.geometry.Path.rectangle_xz" href="#traceon.geometry.Path.rectangle_xz">rectangle_xz</a></code></li>
<li><code><a title="traceon.geometry.Path.rectangle_yz" href="#traceon.geometry.Path.rectangle_yz">rectangle_yz</a></code></li>
<li><code><a title="traceon.geometry.Path.reverse" href="#traceon.geometry.Path.reverse">reverse</a></code></li>
<li><code><a title="traceon.geometry.Path.revolve_x" href="#traceon.geometry.Path.revolve_x">revolve_x</a></code></li>
<li><code><a title="traceon.geometry.Path.revolve_y" href="#traceon.geometry.Path.revolve_y">revolve_y</a></code></li>
<li><code><a title="traceon.geometry.Path.revolve_z" href="#traceon.geometry.Path.revolve_z">revolve_z</a></code></li>
<li><code><a title="traceon.geometry.Path.spline_through_points" href="#traceon.geometry.Path.spline_through_points">spline_through_points</a></code></li>
<li><code><a title="traceon.geometry.Path.starting_point" href="#traceon.geometry.Path.starting_point">starting_point</a></code></li>
<li><code><a title="traceon.geometry.Path.velocity_vector" href="#traceon.geometry.Path.velocity_vector">velocity_vector</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="traceon.geometry.PathCollection" href="#traceon.geometry.PathCollection">PathCollection</a></code></h4>
<ul class="two-column">
<li><code><a title="traceon.geometry.PathCollection.__add__" href="#traceon.geometry.PathCollection.__add__">__add__</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.__iadd__" href="#traceon.geometry.PathCollection.__iadd__">__iadd__</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.extrude" href="#traceon.geometry.PathCollection.extrude">extrude</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.extrude_by_path" href="#traceon.geometry.PathCollection.extrude_by_path">extrude_by_path</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.mesh" href="#traceon.geometry.PathCollection.mesh">mesh</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.name" href="#traceon.geometry.PathCollection.name">name</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.revolve_x" href="#traceon.geometry.PathCollection.revolve_x">revolve_x</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.revolve_y" href="#traceon.geometry.PathCollection.revolve_y">revolve_y</a></code></li>
<li><code><a title="traceon.geometry.PathCollection.revolve_z" href="#traceon.geometry.PathCollection.revolve_z">revolve_z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="traceon.geometry.Surface" href="#traceon.geometry.Surface">Surface</a></code></h4>
<ul class="">
<li><code><a title="traceon.geometry.Surface.__add__" href="#traceon.geometry.Surface.__add__">__add__</a></code></li>
<li><code><a title="traceon.geometry.Surface.__call__" href="#traceon.geometry.Surface.__call__">__call__</a></code></li>
<li><code><a title="traceon.geometry.Surface.aperture" href="#traceon.geometry.Surface.aperture">aperture</a></code></li>
<li><code><a title="traceon.geometry.Surface.box" href="#traceon.geometry.Surface.box">box</a></code></li>
<li><code><a title="traceon.geometry.Surface.disk_xy" href="#traceon.geometry.Surface.disk_xy">disk_xy</a></code></li>
<li><code><a title="traceon.geometry.Surface.disk_xz" href="#traceon.geometry.Surface.disk_xz">disk_xz</a></code></li>
<li><code><a title="traceon.geometry.Surface.disk_yz" href="#traceon.geometry.Surface.disk_yz">disk_yz</a></code></li>
<li><code><a title="traceon.geometry.Surface.extrude_boundary" href="#traceon.geometry.Surface.extrude_boundary">extrude_boundary</a></code></li>
<li><code><a title="traceon.geometry.Surface.extrude_boundary_by_path" href="#traceon.geometry.Surface.extrude_boundary_by_path">extrude_boundary_by_path</a></code></li>
<li><code><a title="traceon.geometry.Surface.from_boundary_paths" href="#traceon.geometry.Surface.from_boundary_paths">from_boundary_paths</a></code></li>
<li><code><a title="traceon.geometry.Surface.get_boundary_paths" href="#traceon.geometry.Surface.get_boundary_paths">get_boundary_paths</a></code></li>
<li><code><a title="traceon.geometry.Surface.mesh" href="#traceon.geometry.Surface.mesh">mesh</a></code></li>
<li><code><a title="traceon.geometry.Surface.rectangle_xy" href="#traceon.geometry.Surface.rectangle_xy">rectangle_xy</a></code></li>
<li><code><a title="traceon.geometry.Surface.rectangle_xz" href="#traceon.geometry.Surface.rectangle_xz">rectangle_xz</a></code></li>
<li><code><a title="traceon.geometry.Surface.rectangle_yz" href="#traceon.geometry.Surface.rectangle_yz">rectangle_yz</a></code></li>
<li><code><a title="traceon.geometry.Surface.revolve_boundary_x" href="#traceon.geometry.Surface.revolve_boundary_x">revolve_boundary_x</a></code></li>
<li><code><a title="traceon.geometry.Surface.revolve_boundary_y" href="#traceon.geometry.Surface.revolve_boundary_y">revolve_boundary_y</a></code></li>
<li><code><a title="traceon.geometry.Surface.revolve_boundary_z" href="#traceon.geometry.Surface.revolve_boundary_z">revolve_boundary_z</a></code></li>
<li><code><a title="traceon.geometry.Surface.spanned_by_paths" href="#traceon.geometry.Surface.spanned_by_paths">spanned_by_paths</a></code></li>
<li><code><a title="traceon.geometry.Surface.sphere" href="#traceon.geometry.Surface.sphere">sphere</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="traceon.geometry.SurfaceCollection" href="#traceon.geometry.SurfaceCollection">SurfaceCollection</a></code></h4>
<ul class="">
<li><code><a title="traceon.geometry.SurfaceCollection.__add__" href="#traceon.geometry.SurfaceCollection.__add__">__add__</a></code></li>
<li><code><a title="traceon.geometry.SurfaceCollection.__iadd__" href="#traceon.geometry.SurfaceCollection.__iadd__">__iadd__</a></code></li>
<li><code><a title="traceon.geometry.SurfaceCollection.mesh" href="#traceon.geometry.SurfaceCollection.mesh">mesh</a></code></li>
<li><code><a title="traceon.geometry.SurfaceCollection.name" href="#traceon.geometry.SurfaceCollection.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
