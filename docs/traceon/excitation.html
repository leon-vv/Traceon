<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>traceon.excitation API documentation</title>
<meta name="description" content="The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>traceon.excitation</code></h1>
</header>
<section id="section-intro">
<p>The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the <code><a title="traceon.geometry" href="geometry.html">traceon.geometry</a></code> module. Currently only electrostatic excitations are supported.</p>
<p>The possible excitations are as follows:</p>
<ul>
<li>Fixed voltage (electrode connect to a power supply)</li>
<li>Voltage function (a generic Python function specifies the voltage as a function of position)</li>
<li>Dielectric, with arbitrary electric permittivity</li>
<li>Floating conductor, with an arbitrary total charge on the surface</li>
</ul>
<p>Once the excitation is specified, it can be passed to <code><a title="traceon.solver.solve_bem" href="solver.html#traceon.solver.solve_bem">solve_bem()</a></code> to compute the resulting field.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The excitation module allows to specify the excitation (or element types) of the different physical groups (electrodes)
created with the `traceon.geometry` module. Currently only electrostatic excitations are supported.

The possible excitations are as follows:

- Fixed voltage (electrode connect to a power supply)
- Voltage function (a generic Python function specifies the voltage as a function of position)
- Dielectric, with arbitrary electric permittivity
- Floating conductor, with an arbitrary total charge on the surface

Once the excitation is specified, it can be passed to `traceon.solver.solve_bem` to compute the resulting field.
&#34;&#34;&#34;


from enum import IntEnum

import numpy as np

from .geometry import Symmetry

class ExcitationType(IntEnum):
    &#34;&#34;&#34;Possible excitation that can be applied to elements of the geometry. See the methods of `Excitation` for documentation.&#34;&#34;&#34;
    VOLTAGE_FIXED = 1
    VOLTAGE_FUN = 2
    DIELECTRIC = 3
    FLOATING_CONDUCTOR = 4

    def __str__(self):
        if self == ExcitationType.VOLTAGE_FIXED:
            return &#39;voltage fixed&#39;
        elif self == ExcitationType.VOLTAGE_FUN:
            return &#39;voltage function&#39;
        elif self == ExcitationType.DIELECTRIC:
            return &#39;dielectric&#39;
        elif self == ExcitationType.FLOATING_CONDUCTOR:
            return &#39;floating conductor&#39;


class Excitation:
    &#34;&#34;&#34; &#34;&#34;&#34;
     
    def __init__(self, mesh):
        self.mesh = mesh
        self.electrodes = mesh.get_electrodes()
        self.excitation_types = {}
    
    def __str__(self):
        return f&#39;&lt;Traceon Excitation,\n\t&#39; \
            + &#39;\n\t&#39;.join([f&#39;{n}={v} ({t})&#39; for n, (t, v) in self.excitation_types.items()]) \
            + &#39;&gt;&#39;
     
    def add_voltage(self, **kwargs):
        &#34;&#34;&#34;
        Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
            calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
            Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
            Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
        
        &#34;&#34;&#34;
        for name, voltage in kwargs.items():
            assert name in self.electrodes
            if isinstance(voltage, int) or isinstance(voltage, float):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
            elif callable(voltage):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
            else:
                raise NotImplementedError(&#39;Unrecognized voltage value&#39;)

    def add_dielectric(self, **kwargs):
        &#34;&#34;&#34;
        Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
            calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
         
        &#34;&#34;&#34;
        for name, permittivity in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)

    def add_floating_conductor(self, **kwargs):
        &#34;&#34;&#34;
        Specify geometric elements as floating conductors, and specify the total charge on the conductor.
         
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
            calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
            a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
            
        &#34;&#34;&#34;
        for name, charge in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)
     
    def _get_element_type(self):
        if self.mesh.symmetry == Symmetry.THREE_D:
            return &#39;triangle&#39;
        else:
            return &#39;line&#39;
    
        
    def _split_for_superposition(self):
        
        # Names that have a fixed voltage excitation, not equal to 0.0
        types = self.excitation_types
        non_zero_fixed = [n for n, (t, v) in types.items() if t == ExcitationType.VOLTAGE_FIXED and v != 0.0]
        
        excitations = []
         
        for name in non_zero_fixed:

            new_types_dict = {}
             
            for n, (t, v) in types.items():
                assert t != ExcitationType.VOLTAGE_FUN, &#34;VOLTAGE_FUN excitation not supported for superposition.&#34;
                assert (t != ExcitationType.FLOATING_CONDUCTOR or v == 0.0), &#34;FLOATING_CONDUCTOR only supported in superposition if total charge equals zero.&#34;
                 
                if n == name:
                    new_types_dict[n] = (t, 1.0)
                elif t == ExcitationType.VOLTAGE_FIXED:
                    new_types_dict[n] = (t, 0.0)
                else:
                    new_types_dict[n] = (t, v)
            
            exc = Excitation(self.mesh)
            exc.excitation_types = new_types_dict
            excitations.append(exc)

        assert len(non_zero_fixed) == len(excitations)
        return {n:e for (n,e) in zip(non_zero_fixed, excitations)}

    def get_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. 
    
        Returns
        --------
        A tuple of two elements: (points, names). points is a Numpy array of shape (N, 2, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
        This array contains the vertices of the line elements or the triangles. \
        names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
        while the values are Numpy arrays of indices that can be used to index the points array.
        &#34;&#34;&#34;
        type_ = self._get_element_type()
        mesh = self.mesh.mesh
        vertices = mesh.cells_dict[type_] # Indices making up the lines and triangles
        inactive = np.full(len(vertices), True)
        names = {}
        
        for name in self.excitation_types.keys():
            inactive[ mesh.cell_sets_dict[name][type_] ] = False
        
        map_index = np.arange(len(vertices)) - np.cumsum(inactive)
        
        for name in self.excitation_types.keys():
            names[name] = map_index[mesh.cell_sets_dict[name][type_]]
              
        return mesh.points[ vertices[~inactive] ], names
    
    def get_number_of_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. This is the length of the points
        array returned by the `Excitation.get_active_elements`.

        Returns
        --------
        int, giving the number of elements. &#34;&#34;&#34;
        type_ = self._get_element_type()
        mesh = self.mesh.mesh
        
        return sum(len(mesh.cell_sets_dict[n][type_]) for n in self.excitation_types.keys())


        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="traceon.excitation.Excitation"><code class="flex name class">
<span>class <span class="ident">Excitation</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Excitation:
    &#34;&#34;&#34; &#34;&#34;&#34;
     
    def __init__(self, mesh):
        self.mesh = mesh
        self.electrodes = mesh.get_electrodes()
        self.excitation_types = {}
    
    def __str__(self):
        return f&#39;&lt;Traceon Excitation,\n\t&#39; \
            + &#39;\n\t&#39;.join([f&#39;{n}={v} ({t})&#39; for n, (t, v) in self.excitation_types.items()]) \
            + &#39;&gt;&#39;
     
    def add_voltage(self, **kwargs):
        &#34;&#34;&#34;
        Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
            calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
            Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
            Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
        
        &#34;&#34;&#34;
        for name, voltage in kwargs.items():
            assert name in self.electrodes
            if isinstance(voltage, int) or isinstance(voltage, float):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
            elif callable(voltage):
                self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
            else:
                raise NotImplementedError(&#39;Unrecognized voltage value&#39;)

    def add_dielectric(self, **kwargs):
        &#34;&#34;&#34;
        Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
        
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
            calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
         
        &#34;&#34;&#34;
        for name, permittivity in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)

    def add_floating_conductor(self, **kwargs):
        &#34;&#34;&#34;
        Specify geometric elements as floating conductors, and specify the total charge on the conductor.
         
        Parameters
        ----------
        **kwargs : dict
            The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
            calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
            a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
            
        &#34;&#34;&#34;
        for name, charge in kwargs.items():
            assert name in self.electrodes
            self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)
     
    def _get_element_type(self):
        if self.mesh.symmetry == Symmetry.THREE_D:
            return &#39;triangle&#39;
        else:
            return &#39;line&#39;
    
        
    def _split_for_superposition(self):
        
        # Names that have a fixed voltage excitation, not equal to 0.0
        types = self.excitation_types
        non_zero_fixed = [n for n, (t, v) in types.items() if t == ExcitationType.VOLTAGE_FIXED and v != 0.0]
        
        excitations = []
         
        for name in non_zero_fixed:

            new_types_dict = {}
             
            for n, (t, v) in types.items():
                assert t != ExcitationType.VOLTAGE_FUN, &#34;VOLTAGE_FUN excitation not supported for superposition.&#34;
                assert (t != ExcitationType.FLOATING_CONDUCTOR or v == 0.0), &#34;FLOATING_CONDUCTOR only supported in superposition if total charge equals zero.&#34;
                 
                if n == name:
                    new_types_dict[n] = (t, 1.0)
                elif t == ExcitationType.VOLTAGE_FIXED:
                    new_types_dict[n] = (t, 0.0)
                else:
                    new_types_dict[n] = (t, v)
            
            exc = Excitation(self.mesh)
            exc.excitation_types = new_types_dict
            excitations.append(exc)

        assert len(non_zero_fixed) == len(excitations)
        return {n:e for (n,e) in zip(non_zero_fixed, excitations)}

    def get_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. 
    
        Returns
        --------
        A tuple of two elements: (points, names). points is a Numpy array of shape (N, 2, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
        This array contains the vertices of the line elements or the triangles. \
        names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
        while the values are Numpy arrays of indices that can be used to index the points array.
        &#34;&#34;&#34;
        type_ = self._get_element_type()
        mesh = self.mesh.mesh
        vertices = mesh.cells_dict[type_] # Indices making up the lines and triangles
        inactive = np.full(len(vertices), True)
        names = {}
        
        for name in self.excitation_types.keys():
            inactive[ mesh.cell_sets_dict[name][type_] ] = False
        
        map_index = np.arange(len(vertices)) - np.cumsum(inactive)
        
        for name in self.excitation_types.keys():
            names[name] = map_index[mesh.cell_sets_dict[name][type_]]
              
        return mesh.points[ vertices[~inactive] ], names
    
    def get_number_of_active_elements(self):
        &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
        an excitation to them has been applied. This is the length of the points
        array returned by the `Excitation.get_active_elements`.

        Returns
        --------
        int, giving the number of elements. &#34;&#34;&#34;
        type_ = self._get_element_type()
        mesh = self.mesh.mesh
        
        return sum(len(mesh.cell_sets_dict[n][type_]) for n in self.excitation_types.keys())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="traceon.excitation.Excitation.add_dielectric"><code class="name flex">
<span>def <span class="ident">add_dielectric</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
calling the function as <code>add_dielectric(spacer=2)</code> assign the relative dielectric constant of 2 to the <code>spacer</code> physical group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dielectric(self, **kwargs):
    &#34;&#34;&#34;
    Assign a dielectric constant to the geometries assigned the given name (or physical group in GMSH terminology).
    
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the relative dielectric constants. For example,
        calling the function as `add_dielectric(spacer=2)` assign the relative dielectric constant of 2 to the `spacer` physical group.
     
    &#34;&#34;&#34;
    for name, permittivity in kwargs.items():
        assert name in self.electrodes
        self.excitation_types[name] = (ExcitationType.DIELECTRIC, permittivity)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.add_floating_conductor"><code class="name flex">
<span>def <span class="ident">add_floating_conductor</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify geometric elements as floating conductors, and specify the total charge on the conductor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
calling the function as <code>add_floating_conductor(spacer=10)</code> specifies the physical group <code>spacer</code> as a floating conductor with
a total charge on its surface equal to 10. For the unit of charge, see the section 'Units' on the <code><a title="traceon" href="index.html">traceon</a></code> page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_floating_conductor(self, **kwargs):
    &#34;&#34;&#34;
    Specify geometric elements as floating conductors, and specify the total charge on the conductor.
     
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the charge on the conductors. For example,
        calling the function as `add_floating_conductor(spacer=10)` specifies the physical group `spacer` as a floating conductor with
        a total charge on its surface equal to 10. For the unit of charge, see the section &#39;Units&#39; on the `traceon` page.
        
    &#34;&#34;&#34;
    for name, charge in kwargs.items():
        assert name in self.electrodes
        self.excitation_types[name] = (ExcitationType.FLOATING_CONDUCTOR, charge)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.add_voltage"><code class="name flex">
<span>def <span class="ident">add_voltage</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
calling the function as <code>add_voltage(lens=50)</code> assigns a 50V value to the geometry elements part of the 'lens' physical group.
Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_voltage(self, **kwargs):
    &#34;&#34;&#34;
    Apply a fixed voltage to the geometries assigned the given name (or physical group in GMSH terminology).
    
    Parameters
    ----------
    **kwargs : dict
        The keys of the dictionary are the geometry names, while the values are the voltages in units of Volt. For example,
        calling the function as `add_voltage(lens=50)` assigns a 50V value to the geometry elements part of the &#39;lens&#39; physical group.
        Alternatively, the value can be a function, which takes x, y, z coordinates as argument and returns the voltage at that position.
        Note that in 2D symmetries (such as radial symmetry) the z value for this function will always be zero.
    
    &#34;&#34;&#34;
    for name, voltage in kwargs.items():
        assert name in self.electrodes
        if isinstance(voltage, int) or isinstance(voltage, float):
            self.excitation_types[name] = (ExcitationType.VOLTAGE_FIXED, voltage)
        elif callable(voltage):
            self.excitation_types[name] = (ExcitationType.VOLTAGE_FUN, voltage)
        else:
            raise NotImplementedError(&#39;Unrecognized voltage value&#39;)</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_active_elements"><code class="name flex">
<span>def <span class="ident">get_active_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get elements in the mesh that are active, in the sense that
an excitation to them has been applied. </p>
<h2 id="returns">Returns</h2>
<p>A tuple of two elements: (points, names). points is a Numpy array of shape (N, 2, 3) in the case of 2D and (N, 3, 3) in the case of 3D.
This array contains the vertices of the line elements or the triangles.
names is a dictionary, the keys being the names of the physical groups mentioned by this excitation,
while the values are Numpy arrays of indices that can be used to index the points array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_active_elements(self):
    &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
    an excitation to them has been applied. 

    Returns
    --------
    A tuple of two elements: (points, names). points is a Numpy array of shape (N, 2, 3) in the case of 2D and (N, 3, 3) in the case of 3D. \
    This array contains the vertices of the line elements or the triangles. \
    names is a dictionary, the keys being the names of the physical groups mentioned by this excitation, \
    while the values are Numpy arrays of indices that can be used to index the points array.
    &#34;&#34;&#34;
    type_ = self._get_element_type()
    mesh = self.mesh.mesh
    vertices = mesh.cells_dict[type_] # Indices making up the lines and triangles
    inactive = np.full(len(vertices), True)
    names = {}
    
    for name in self.excitation_types.keys():
        inactive[ mesh.cell_sets_dict[name][type_] ] = False
    
    map_index = np.arange(len(vertices)) - np.cumsum(inactive)
    
    for name in self.excitation_types.keys():
        names[name] = map_index[mesh.cell_sets_dict[name][type_]]
          
    return mesh.points[ vertices[~inactive] ], names</code></pre>
</details>
</dd>
<dt id="traceon.excitation.Excitation.get_number_of_active_elements"><code class="name flex">
<span>def <span class="ident">get_number_of_active_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get elements in the mesh that are active, in the sense that
an excitation to them has been applied. This is the length of the points
array returned by the <code><a title="traceon.excitation.Excitation.get_active_elements" href="#traceon.excitation.Excitation.get_active_elements">Excitation.get_active_elements()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>int, giving the number of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_active_elements(self):
    &#34;&#34;&#34;Get elements in the mesh that are active, in the sense that
    an excitation to them has been applied. This is the length of the points
    array returned by the `Excitation.get_active_elements`.

    Returns
    --------
    int, giving the number of elements. &#34;&#34;&#34;
    type_ = self._get_element_type()
    mesh = self.mesh.mesh
    
    return sum(len(mesh.cell_sets_dict[n][type_]) for n in self.excitation_types.keys())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="traceon.excitation.ExcitationType"><code class="flex name class">
<span>class <span class="ident">ExcitationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Possible excitation that can be applied to elements of the geometry. See the methods of <code><a title="traceon.excitation.Excitation" href="#traceon.excitation.Excitation">Excitation</a></code> for documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExcitationType(IntEnum):
    &#34;&#34;&#34;Possible excitation that can be applied to elements of the geometry. See the methods of `Excitation` for documentation.&#34;&#34;&#34;
    VOLTAGE_FIXED = 1
    VOLTAGE_FUN = 2
    DIELECTRIC = 3
    FLOATING_CONDUCTOR = 4

    def __str__(self):
        if self == ExcitationType.VOLTAGE_FIXED:
            return &#39;voltage fixed&#39;
        elif self == ExcitationType.VOLTAGE_FUN:
            return &#39;voltage function&#39;
        elif self == ExcitationType.DIELECTRIC:
            return &#39;dielectric&#39;
        elif self == ExcitationType.FLOATING_CONDUCTOR:
            return &#39;floating conductor&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="traceon.excitation.ExcitationType.DIELECTRIC"><code class="name">var <span class="ident">DIELECTRIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.FLOATING_CONDUCTOR"><code class="name">var <span class="ident">FLOATING_CONDUCTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.VOLTAGE_FIXED"><code class="name">var <span class="ident">VOLTAGE_FIXED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="traceon.excitation.ExcitationType.VOLTAGE_FUN"><code class="name">var <span class="ident">VOLTAGE_FUN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="traceon" href="index.html">traceon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="traceon.excitation.Excitation" href="#traceon.excitation.Excitation">Excitation</a></code></h4>
<ul class="">
<li><code><a title="traceon.excitation.Excitation.add_dielectric" href="#traceon.excitation.Excitation.add_dielectric">add_dielectric</a></code></li>
<li><code><a title="traceon.excitation.Excitation.add_floating_conductor" href="#traceon.excitation.Excitation.add_floating_conductor">add_floating_conductor</a></code></li>
<li><code><a title="traceon.excitation.Excitation.add_voltage" href="#traceon.excitation.Excitation.add_voltage">add_voltage</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_active_elements" href="#traceon.excitation.Excitation.get_active_elements">get_active_elements</a></code></li>
<li><code><a title="traceon.excitation.Excitation.get_number_of_active_elements" href="#traceon.excitation.Excitation.get_number_of_active_elements">get_number_of_active_elements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="traceon.excitation.ExcitationType" href="#traceon.excitation.ExcitationType">ExcitationType</a></code></h4>
<ul class="">
<li><code><a title="traceon.excitation.ExcitationType.DIELECTRIC" href="#traceon.excitation.ExcitationType.DIELECTRIC">DIELECTRIC</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.FLOATING_CONDUCTOR" href="#traceon.excitation.ExcitationType.FLOATING_CONDUCTOR">FLOATING_CONDUCTOR</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.VOLTAGE_FIXED" href="#traceon.excitation.ExcitationType.VOLTAGE_FIXED">VOLTAGE_FIXED</a></code></li>
<li><code><a title="traceon.excitation.ExcitationType.VOLTAGE_FUN" href="#traceon.excitation.ExcitationType.VOLTAGE_FUN">VOLTAGE_FUN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>